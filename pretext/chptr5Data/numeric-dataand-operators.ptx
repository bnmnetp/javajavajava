<section xml:id="numeric-dataand-operators">
  <title>Numeric Data and Operators</title>
  <introduction>
    <p>
      Java has two kinds of numeric data:
      integers, which have no fractional part,
      and real numbers or <em>floating-point numbers</em>,
      which contain a fractional component.
    </p>
    <p>
      Java recognizes four different kinds of integers: <c>byte</c>, <c>short</c>, <c>int</c>, and 
      <c>long</c>, which are distinguished by the number of
      <em>bits</em> used to represent them.
      A <term>binary digit</term>, or <term>bit</term>,
      is a 0 or a 1. (Recall that computers read instructions 
      as series of 0s and 1s.) Java has two different kinds of real numbers, <c>float</c> and <c>double</c>, which are also distinguished by the number of bits used to represent them.
      See <xref ref="tab-numerics">Table</xref>.
    </p>
    <table xml:id="tab-numerics">
      <title>Java's numeric types</title>
      <tabular>
      <row bottom="minor" left="minor">
          <cell><term> Type</term></cell>
          <cell><term>Bits</term></cell>
          <cell><term>Range of Values</term></cell>
        </row>
        <row>
          <cell><c>byte</c></cell>
          <cell><nbsp/>8</cell>
          <cell><m>-128  to  +127</m></cell>
        </row>
        <row>
          <cell><c>short</c></cell>
          <cell>16</cell>
          <cell><m>-32768 \hbox{ to } 32767</m></cell>
        </row>
        <row>
          <cell><c>int</c></cell>
          <cell>32</cell>
          <cell><m>-2147483648 \hbox{ to } 2147483647</m></cell>
        </row>
        <row>
          <cell><c>long</c></cell>
          <cell>64</cell>
          <cell><m>-2^{63}  \hbox{ to }  2^{63}-1</m></cell>
        </row>
        <row>
          <cell><c>float</c></cell>
          <cell>32</cell>
          <cell><m>-3.40292347E+38 \hbox{ to }  +3.40292347E+38</m></cell>
        </row>
        <row bottom="minor">
          <cell><c>double</c></cell>
          <cell>64</cell>
          <cell><m>-1.79769313486231570E+308   \hbox{ to }  +1.79769313486231570E+308</m></cell>
        </row>
      </tabular>
    </table>
    <p>
      The more bits a data type has,
      the more values it can represent.
      One bit can represent two possible values, 1 and 0, which can be used to stand for true and false,
      respectively.
      Two bits can represent four possible values: 00, 01, 10, and 11;
      three bits can represent eight possible values: 000, 001, 010, 100, 101, 110, 011, 111.
    </p>
    <p>
    <definition>
      An <em>n</em>-bit quantity can represent <m>2^n</m> different values.
    </definition>
    </p>
    <p>
      <xref ref="tab-numerics">Table</xref>
      As illustrated in <xref ref="tab-numerics">Table</xref>, the various integer types 
      represent positive or negative whole numbers.
      Perhaps the most commonly used integer type in Java is the <c>int</c> type,
      which is represented in 32 bits.
      This means that Java can represent <m>2^{32}</m> different <c>int</c> values,
      which range from <m>-2{,}147{,}483{,}648</m> to <m>2{,}147{,}483{,}647</m>,
      that is, from <m>-2^{31}</m> to <m>(2^{31} -1)</m>.
      Similarly, an 8-bit integer,
      a <c>byte</c>, can represent <m>2^8</m> or 256  different values,
      ranging from <m>-128</m> to <m>+127</m>.
      A 16-bit integer,
      a <c>short</c>, can represent <m>2^{16}</m> different values,
      which range from <m>-32768</m> to <m>32767</m>.
      And a 64-bit integer,
      a <c>long</c>, can represent whole number values ranging from <m>-2^{63}</m> to <m>2^{63}-1</m>.
    </p>
    <p>
      For floating-point numbers,
      a 32-bit <c>float</c> type can represent <m>2^{32}</m> different real numbers and a 64-bit <c>double</c> value can represent <m>2^{64}</m> different real numbers.
    </p>
    <principle>
      <title>EFFECTIVE DESIGN: Platform Independence</title>
      <p>
        In Java, a data type's size
        (number of bits)
        is part of its definition and,
        therefore, remains consistent across all platforms.
        In C and C++, the size of a data type is dependent on the compiler.
      </p>
    </principle>
    <p>
      It is worth noting that just as model airplanes are representations of real airplanes, 
      Java's numeric types are representations or  models of the numbers we deal with in mathematics.
      In designing Java's data types,
      various trade-offs have been made in order to come up with practical implementations.
    </p>
    <p>
      One trade-off is that the set of integers is infinite,
      but Java's
<c>int</c> type can only represent a finite number of values.
      Similarly,  Java cannot represent the infinite number of values that occur between,
      say, 1.111 and 1.112.
      So, certain real numbers cannot be represented at all.
      For example,
      because Java uses binary numbers to represent its numeric types,
      one number that cannot be represented exactly is <m>\frac{1}{10}</m>.
      This inability to exactly represent a value is known as
      <term>round-off error</term>.
      Being unable to represent certain values can cause problems in a program.
      For example,
      it might be  difficult to represent dollars and cents accurately in a program.
    </p>
    <p>
      Another source of problems in dealing with numeric data is due to limits in their precision.
      For example,
      a decimal number represented as a double value can have a maximum of 17
      <em>significant digits</em>,
      and a <c>float</c> can have a maximum of  8.
      A significant digit is one that contributes to the number's value.
      If you tried to store values such as 12345.6789 or 0.123456789 in a <c>float</c> variable,
      they would be rounded off to 12345.679 and 0.12345679,
      respectively, causing a possible error.
    </p>
    <principle>
      <title>DEBUGGING TIP: Significant Digits</title>
      <p>
        In using numeric data,
        be sure the data type you choose has enough precision to represent 
        the values your program needs.
      </p>
    </principle>
  </introduction>
  <subsection>
    <title>Numeric Operations</title>
    <introduction>
      <p>
        The operations that can be done on numeric data include the standard algebraic operations:
        <em>addition</em> (+), <em>subtraction</em> (<m>-</m>),
        <em>multiplication</em> (*), <em>division</em>
        (/), as well as the <em>modulus</em> (%) operator.
        Note that in Java,
        the multiplication symbol is <c>*</c> and not the <times/>.
        The arithmetic operators are binary operators,  meaning that they each take two operands. 
        <xref ref="tab-numops">Table</xref> compares expressions involving the 
        Java operators with their standard algebraic counterparts.
      </p>
      <table xml:id="tab-numops">
        <title>The standard arithmetic operators arithmetic operators in Java.</title>  
        <tabular>
          <row bottom="minor" left="minor">
            <cell><term>Operation</term></cell>
            <cell><term>Operator</term></cell>
            <cell><term>Java</term></cell>
            <cell><term>Algebra</term></cell>
          </row>
           <row>
            <cell><em>Addition</em></cell>
            <cell><m>+</m></cell>
            <cell><m>x  +  2</m></cell>
            <cell><m>x  +  2</m></cell>
          </row>
          <row>
            <cell><em>Subtraction</em></cell>
            <cell><m>-</m></cell>
            <cell><m>m  -  2</m></cell>
            <cell><m>m  -  2</m></cell>
          </row>
          <row>
            <cell><em>Multiplication</em></cell>
            <cell>*</cell>
            <cell><m>m</m>   *   <m>2</m></cell>
            <cell><m>2m  \hbox{ or }  m \times 2</m></cell>
          </row>
          <row>
            <cell><em>Division</em></cell>
            <cell>/</cell>
            <cell><m>x  /  y</m></cell>
            <cell><m>x  \div  y  \hbox{ or }  \frac{x}{y}</m></cell>
          </row>
          <row bottom="minor">
            <cell><em>Modulus</em></cell>
            <cell>%</cell>
            <cell><m>x  \%  y</m></cell>
            <cell><m>x  \hbox{ modulo }  y</m> (for  integers <m>x</m> and <m>y</m>)</cell>
          </row>
        </tabular>
      </table>
      <p>
        Although these operations should seem familiar,
        there are some important differences between their use in algebra and their use in a Java program.
        Consider the following list of expressions:
      </p>
 <program language="java"><input>
3 / 2     ==>  value 1     An integer result
3.0 / 2.0 ==>  value 1.5   A floating-point result
3 / 2.0   ==>  value 1.5   A floating-point result
3.0 / 2   ==>  value 1.5   A floating-point result
 </input></program>
      <p>
        In each of these cases we are dividing the quantity 3 by the quantity<nbsp/>2.
        However, different results are obtained depending on the <em>type</em>
        of the operands involved.
        When both operands are integers, as in (3/2),
        the result must also be an integer.
            <idx><h>integer division</h></idx>
        Hence, (3/2) has the value 1, an integer.
        Because integers cannot have a fractional part,
        the 0.5 is simply discarded.
        Integer division (/) always gives an integer  result.
        Thus, the value of (6/2) is 3 and the value of (7/2) is also 3.
        Because 3.5 is not an integer,
        the result of dividing 7 by 2 cannot be 3.5.
      </p>
      <principle>
        <title>DEBUGGING TIP: Integer Division</title>
        <p>
          A common source of error among beginning programmers 
          is forgetting that integer division always gives an integer result.
        </p>
      </principle>
      <p>
        On the other hand, when either operand is a real number,
        as in the last three cases, the result is a real number.
        Thus, while the same symbol (/) is used for dividing integers and real numbers,
        there are really two different operations involved here:
        <em>integer division</em> and <em>floating-point division
            <idx><h>floating-point division</h></idx>
        </em>.
        Using the same symbol (/) for different operations
        (integer division and real division)
        is known as <term>operator overloading</term>.
        It is similar to method overloading,
        which was discussed in Chapter<nbsp/>3.
      </p>
      <p>
        What if you want to keep the remainder of an integer division?
        Java  provides the modulus operator (%), which takes two operands.
        The expression (7 % 5) gives the remainder after dividing 7 by 5 <mdash/> that is, 
        2 in this case.
        In general, the expression <m>(m \; \% \; n)</m>
        (read <em>m</em> mod <em>n</em>)
        gives the remainder after <em>m</em>
        is divided by <em>n</em>.
        Here are several examples:
      </p>
 <program language="java"><input>
7 % 5   ==> 7 mod 5 equals 2
5 % 7   ==> 5 mod 7 equals 5
-7 % 5  ==> -7 mod 5 equals -2
7 % -5  ==> 7 mod -5 equals 2
 </input></program>
      <p>
        The best way to interpret these examples is to perform long division on the operands keeping both the quotient and the remainder.
        For example, when you do long division on <m>-7 \div 5</m>,
        you get a quotient of -1 and a remainder of -2.
        The quotient is the value of <m>-7/5</m> and the remainder is the value of <m>-7 \% 5</m>.
        When you do long division on <m>7 \div -5</m>,
        you get a quotient of -1 and a remainder of 2.
        The quotient is the value of <m>7/-5</m> and the remainder is the value of <m>7\%-5</m>.
      </p>
      <p>
        We will encounter many practical uses for the modulus operator in our programs.
        For a simple example,
        we use it when we want to determine whether an integer is even or odd.
        Numbers that leave a 0 remainder when divided by 2 are even:
      </p>
 <program language="java"><input>
if (N % 2 == 0)
    System.out.println(N + " is even");
 </input></program>
      <p>
        More generally,
        we could use the mod operator to define divisibility by 3, 4, 10, or by any number.
      </p>
    </introduction>
    <subsubsection xml:id="promotion-rules">
      <title>Numeric Promotion Rules</title>
      <p>
        Java is considered a <em>strongly typed</em>
        language because all expressions in Java,
        such as  (3/2),
        have a type associated with them.
        In cases where one arithmetic operand is an integer and one is a floating-point number, Java <em>promotes</em>
        the integer into a floating-point value and performs a floating-point operation.
      </p>
      <p>
        <term>Promotion</term> is a matter of converting one type to another type.
        For example, in the expression (5 + 4.0),
        the value 5 must be promoted to 5.0 before floating-point addition can be performed on (5.0 + 4.0).
        Generally speaking,
        automatic promotions such as these are allowed in Java whenever it is possible to perform the promotion
        <em>without loss of information</em>.
        Because an integer (5) does not have a fractional component,
        no information will be lost in promoting it to a real number (5.0).
        On the other hand,
        you cannot automatically convert a real number (5.4) to an integer (5) because that might lead to loss of information.
        This leads to the following rule:
      </p>
      <principle>
        <title>Integer Promotion</title>
        <p>
          In an operation that contains an integer and a floating-point operand,
          the integer is <term>promoted</term>
          to a floating-point value <term>before</term>
          the operation is performed.
        </p>
      </principle>
      <p>
        This rule is actually an instance of a more general rule: 
        whenever an expression involves operands of different types,
        some operands must be converted before the expression can be evaluated.
        Consider the following example:
      </p>
 <program language="java"><input>
byte n = 125;
short m = 32000;
n * m;
 </input></program>
      <p>
        In this case,
        <em>(n * m)</em> involves two different integer 
        types, <c>byte</c> and <c>short</c>. Before evaluating this 
        expression Java must first promote the <c>byte</c> to a
        <c>short</c> and carry out the operation as the multiplication of two
        <c>short</c> s.
        Conversion of <c>short</c> to <c>byte</c> would not be possible 
        because there's no way to represent the value 32000 as a <c>byte</c>.
      </p>
      <p>
        It is important to note that this conversion rule applies 
        regardless of the actual values of the operands.
        In applying the rule, Java looks at the operand's type,
        not its value.
        So even if <em>m</em> were assigned a value that could be represented as a byte
        (for example, 100),
        the  promotion would still go from smaller to larger type.
        This leads to following the general rule:
      </p>
      <principle>
        <title>Type Promotion Rule</title>
        <p>
          In general, when two different types are involved in an operation,
          the smaller type <mdash/> i.e.,the one with fewer bits <mdash/> 
          is converted to the larger type before the operation is performed.
          To do otherwise would risk losing information.
        </p>
      </principle>
      <p>
        <xref ref="tab-promotion">Table</xref> summarizes the actual promotion rules used 
        by Java in evaluating expressions involving mixed operands.
        Note that the last rule implies that integer expressions involving <c>byte</c> or
        <c>short</c> or <c>int</c> are performed as <c>int</c>. 
        This explains why integer literals <mdash/> such as <m>56</m> or <m>-108</m> <mdash/> 
        are represented as <c>int</c> types in Java.
      </p>
      <table xml:id="tab-promotion">
        <title>Java promotion rules for mixed arithmetic operators.
        If two rules apply, choose the one that occurs first in this table.</title>
        <tabular>
          <row bottom="minor"  left="minor">
            <cell>If either operand is</cell>
            <cell></cell>
            <cell>The other is promoted to</cell>
          </row>
          <row>
            <cell><c>double</c></cell>
            <cell></cell>
            <cell><c>double</c></cell>
          </row>
          <row>
            <cell><c>float</c></cell>
            <cell></cell>
            <cell><c>float</c></cell>
          </row>
          <row>
            <cell><c>long</c></cell>
            <cell></cell>
            <cell><c>long</c></cell>
          </row>
          <row  bottom="minor">
            <cell><c>byte</c><em>or</em><c>short</c></cell>
            <cell></cell>
            <cell><c>int</c></cell>
          </row>
        </tabular>
      </table>
    </subsubsection>
  </subsection>

<exercises>
  <title>Self-Study Exercises</title>
  

<exercise label="eval-div-mod">
  <title>Evaluate div and mod</title>
  <statement>
      <p>Match the integer expressions with their values.</p>
  </statement>
  <feedback>
      <p></p>
  </feedback>
  <matches>
      <match>
          <premise>6 / 2</premise>
          <response>3</response>
      </match>
      <match>
          <premise>9 / 2</premise>
          <response>4</response>
      </match>
      <match>
          <premise>6 / 8</premise>
          <response>0</response>
      </match>
      <match>
          <premise>9 % 2</premise>
          <response>1</response>
      </match>
      <match>
        <premise>8 % 6</premise>
        <response>2</response>
      </match>
      <match>
        <premise>5 % 8</premise>
        <response>5</response>
      </match>
      <match>
        <premise>3 % 4</premise>
        <response>3</response>
      </match>
     
  </matches>
</exercise>

 
<exercise label="eval-dec-div">
  <title>Evaluate Decimal Expressions</title>
  <statement>
      <p>Match the expressions with their values, paying special attention to the data type of the results.</p>
  </statement>
  <feedback>
      <p></p>
  </feedback>
  <matches>
      <match>
          <premise>8 / 2.0</premise>
          <response>4.0</response>
      </match>
      <match>
          <premise>9 / 2.0</premise>
          <response>4.5</response>
      </match>
      <match>
          <premise>6 / 8</premise>
          <response>0</response>
      </match>
      <match>
          <premise>0.0 / 2</premise>
          <response>0.0</response>
      </match>
      <match>
        <premise>8.0 / 6.0</premise>
        <response>1.33</response>
      </match>
  </matches>
</exercise>
 

<exercise label="eval-type-promotion">
  <title>Evaluate Type Promotion</title>
  <statement>
      <p>
        Suppose that the following variable declarations are made:
<program language="java"><input>
    byte m = 3;  short n = 4;  int p = 5;  long q = 6;  double r = 7.0;
      </input></program>
        
      Use type promotion rules to determine
       the type of  expression and then evaluate each of the following
       expressions:        
      </p>
    </statement>
  <feedback>
      <p></p>
  </feedback>
  <matches>
      <match>
          <premise> m + n     </premise>
          <response>7</response>
      </match>
      <match>
          <premise>p * q</premise>
          <response>30</response>
      </match>
      <match>
          <premise>m + n + r</premise>
          <response>14.0</response>
      </match>
      <match>
          <premise> p * q * m</premise>
          <response>90</response>
      </match>
      <match>
        <premise>r - m</premise>
        <response>4.0</response>
      </match>
  </matches>
</exercise>
</exercises>

  <subsection xml:id="op-precedence">
    <title>Operator Precedence</title>
    <table xml:id="tab-op-precedence">
      <title>Precedence order of the arithmetic operators.</title>
      <tabular>
        <row bottom="minor" left="minor">
          <cell>Precedence Order</cell>
          <cell>Operator</cell>
          <cell>Operation</cell>
        </row>
        <row>
          <cell>1</cell>
          <cell><m>( \; )</m></cell>
          <cell><em>Parentheses</em></cell>
        </row>
        <row>
          <cell>2</cell>
          <cell><m>\ast \;\; / \;\; \%</m></cell>
          <cell><em>Multiplication, Division, Modulus</em></cell>
        </row>
        <row bottom="minor">
          <cell>3</cell>
          <cell><m>+ \;\; -</m></cell>
          <cell><em>Addition, Subtraction</em></cell>
        </row>
      </tabular>
    </table>
    <p>
      The built-in precedence order for arithmetic operators is shown in 
      <xref ref="tab-op-precedence">Table</xref>.
      Parenthesized 
      expressions have highest precedence
      and are evaluated first.
      Next come the multiplication, division,
      and modulus operators, followed by addition and subtraction.
      When we have an unparenthesized expression that involves both multiplication and addition,
      the multiplication would be done first,
      even if it occurs to the right of the plus sign.
      Operators at the same level in the precedence hierarchy are evaluated from left to right.
      For example, consider the following expression:
    </p>
 <program language="java"><input>
9 + 6 - 3 * 6 / 2
 </input></program>
    <p>
      In this case,
      the first operation to be applied will be the multiplication (*), followed by division (/), followed by addition (+), and then finally the subtraction
      (<m>-</m>).
      We can use parentheses to clarify the order of evaluation.
      A parenthesized expression is evaluated outward from the innermost set of parentheses:
    </p>
 <program language="java"><input>
Step 1.  ( (9 + 6) - ((3 * 6) / 2 ) )
Step 2.  ( (9 + 6) - (18 / 2 ) )
Step 3.  ( (9 + 6) - 9 )
Step 4.  ( 15 - 9 )
Step 5.  6
 </input></program>
    <p>
      Parentheses can
      (and should)
      always be used to clarify the order of operations in an expression.
      For example,
      addition will be performed before multiplication in the following expression:
    </p>
 <program language="java"><input>
(a + b) * c
 </input></program>
    <p>
      Another reason to use parentheses is that Java's precedence and promotion rules will sometimes lead to expressions that look fine but contain subtle errors.
      For example, consider the following expressions:
    </p>
 <program language="java"><input>
System.out.println(5/3/2.0);   // 0.5
System.out.println(5/(3/2.0)); // 3.33
 </input></program>
    <p>
      The first gives a result of 0.5, but the use of parentheses in the second gives a result of 3.33.
      If the second is the expected interpretation,
      then the parentheses here helped avoid a subtle semantic error.
    </p>
    <principle>
      <title>PROGRAMMING TIP: Parenthesize!</title>
      <p>
        To avoid subtle bugs caused by Java's precedence and promotion rules,
        use parentheses to specify the order of evaluation in an expression.
      </p>
    </principle>
    <p>
      \secEXRHone{Self-Study Exercise}
    </p>
  </subsection>
  <subsection xml:id="incr-decr-ops">
    <title>Increment and Decrement Operators</title>
    <p>
      Java provides a number of unary operators that are used to increment or decrement an integer variable.
      For example, the expression <em>k++</em>
      uses the <em>increment operator</em>
          <idx><h>increment operator ++</h></idx>
      <em>++</em> to increment the value of the integer variable <em>k</em>.
      The expression <em>k++</em> is equivalent to the following Java statements:
    </p>
 <program language="java"><input>
int k;
k = k + 1;// Add 1 to k and assign the result back to k
 </input></program>
    <p>
      The unary <em>++</em> operator applies to a single integer operand,
      in this case to the variable <em>k</em>.
      It increments <em>k</em>'s value by 1 and assigns the result back to <em>k</em>.
      It may be used either as a <em>preincrement</em>
          <idx><h>preincrement</h></idx>
      or a <em>postincrement
          <idx><h>postincrement</h></idx>
      </em> operator.
      In the expression <em>k++</em>,
      the operator <em>follows</em> the operand,
      indicating that it is being used as a
      <em>postincrement</em> operator.
      This means that the increment operation is done <em>after</em>
      the operand's value is used.
    </p>
    <p>
      Contrast that with the expression
      <em>++k</em> in which the <em>++</em>
      operator <em>precedes</em> its operand.
      In this case, it is used as a <em>preincrement</em> operator,
      which means that the increment operation is done <em>before</em>
      the operand's value is used.
    </p>
    <p>
      When used in isolation, there is no practical difference between
      <em>k++</em> and <em>++k</em>.
      Both are equivalent to <em>k = k + 1</em>.
      However, when used in conjunction with other operators,
      there is a significant difference between preincrement and postincrement.
      For example, in the following code segment,
    </p>
 <program language="java"><input>
int j = 0, k = 0;   // Initially both j and k are 0
j = ++k;            // Final values of both j and k are 1
 </input></program>
    <p>
      the variable <em>k</em> is incremented <em>before</em>
       its value is assigned to <em>j</em>.
      After execution of the assignment statement,
      <em>j</em> will equal 1 and <em>k</em> will equal 1.
      The sequence is equivalent to
    </p>
 <program language="java"><input>
int j = 0, k = 0;   // Initially both j and k are 0
k = k + 1;
j = k;              // Final values of both j and k are 1
 </input></program>
    <p>
      However, in the following example,
    </p>
 <program language="java"><input>
int i = 0, k = 0; // Initially both i and k are 0
i = k++;          // Final value of i is 0 and k is 1
 </input></program>
    <p>
      the variable <em>k</em> is incremented <em>after</em>
      its value is assigned to <em>i</em>.
      After execution of the assignment statement,
      <em>i</em> will have the value 0 and
      <em>k</em> will have the value 1.
      The preceding sequence is equivalent to
    </p>
 <program language="java"><input>
int i = 0, k = 0;   // Initially both i and k are 0
i = k;
k = k + 1;          // Final value of i is 0 and k is 1
 </input></program>
    <p>
      In addition to the increment operator, Java also supplies the
      <em> decrement<idx><h>decrement operator <ndash/></h></idx>
      </em> operator <em><m>--</m></em>,
      which can also be used in the predecrement
          <idx><h>predecrement</h></idx>
      and postdecrement
          <idx><h>postdecrement</h></idx>
      forms.
      The expression <em><m>--</m> k</em>
      will first decrement <em>k</em>'s value by 1 and then use <em>k</em>
      in any expression in which it is embedded.
      The expression <em>k<m>--</m></em>
      will use the current value of
      <em>k</em> in the expression in which <em>k</em>
      is contained and then it will decrement
      <em>k</em>'s value by 1.
    </p>
    <p>
      <xref ref="tab-incrdecr">Table</xref> summarizes the increment and decrement operators.
      The unary increment and decrement operators have higher precedence than 
      any of the binary arithmetic operators.
    </p>
    <table xml:id="tab-incrdecr">
      <title>Java's increment and decrement operators</title>
      <tabular>
        <row bottom="minor" left="minor">
          <cell>Expression</cell>
          <cell>Operation</cell>
          <cell>Interpretation</cell>
        </row>
        <row>
          <cell><m>j = ++k</m></cell>
          <cell><em>Preincrement</em></cell>
          <cell><m>k=k+1;j=k;</m></cell>
        </row>
        <row>
          <cell><m>j = k++</m></cell>
          <cell><em>Postincrement</em></cell>
          <cell><m>j=k;k=k+1;</m></cell>
        </row>
        <row>
          <cell><m>j = --k</m></cell>
          <cell><em>Predecrement</em></cell>
          <cell><m>k=k-1;j=k;</m></cell>
        </row>
        <row bottom="minor">
          <cell><m>j = k--</m></cell>
          <cell><em>Postdecrement</em></cell>
          <cell><m>j=k;k=k-1;</m></cell>
        </row>
      </tabular>
    </table>
    <principle>
      <title>Pre- and Postincrement/Decrement</title>
      <p>
        If an expression like <term>++k</term>
        or <term><m>--</m>k</term> occurs in an expression,
        <term>k</term> is incremented or decremented <term>before</term>
        its value is used in the rest of the expression.
        If an expression like <term>k++</term>
        or <term>k<m>--</m></term> occurs in an expression,
        <term>k</term> is incremented or decremented <term>after</term>
        its value is used in the rest of the expression.
      </p>
    </principle>
    <principle>
      <title>PROGRAMMING TIP: Increment and Decrement Operators</title>
      <p>
        Because of their subtle behavior,
        be careful in how you use the unary increment and decrement operators.
        They are most appropriate and useful for incrementing and decrementing loop variables,
        as we'll see later.
      </p>
    </principle>
    <exercises xml:id="self-study-exercisesD16">
<title>Self-Study Exercises </title> 

<exercise label="fillin-binary">
  <title>Fill-In Binary</title>
  <statement>
    <p>List all of the binary values 
      that can be represented in 4 bits---that is, all values in the range
      0000 to 1111 in order separated by commas: <var/> </p>
  </statement>
  <setup>
      <var>
          <condition string="0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111">
              <feedback>
                <p>Correct. Parameter variables declared in the method header have local scope and only exist inside the method body.</p>
              </feedback>
          </condition>
          <condition string=".*">
                <feedback>
                    <p>Incorrect. Start from 0000, 0001, ...</p>
                </feedback>
            </condition>
          </var>
          </setup>
          <hint><p>Start from 0000, 0001, ...</p></hint>
          </exercise>

          <exercise label="fillin-6bit">
            <title>6-bit Values</title>
            <statement>
              <p>If a 6-bit representation were used for an integer type, how
                 many different integers could be represented? <var/> </p>
            </statement>
            <setup>
                <var>
                    <condition string="64">
                        <feedback>
                          <p>In 6 bits, you can represent 2^6 = 64 different values.</p>
                        </feedback>
                    </condition>
                    <condition string=".*">
                          <feedback>
                              <p>Incorrect. Remember each bit can be 0 or 1 and you have 6 bits.</p>
                          </feedback>
                      </condition>
                    </var>
                    </setup>
                    <hint><p>With 3 bits, you can represent 3^2 = 32 values.</p></hint>
                    </exercise>
                    <exercise label="fillin-data-type">
                      <title>Data Type</title>
                      <statement>
                        <p>If you were writing a program to process scientific data that
                         had to be accurate to at least 12 significant (decimal) digits,
                         what type of data would you use?<var/> </p>
                      </statement>
                      <setup>
                          <var>
                              <condition string="double">
                                  <feedback>
                                    <p>If you have to represent up to 12 significant digits, you should use the data type
                                      <c>double</c>, which goes up to 17 digits.</p>
                                  </feedback>
                              </condition>
                              <condition string=".*">
                                    <feedback>
                                        <p>Incorrect. Some data types you could use are 
                                          <c>byte</c>, <c>short</c>, <c>int</c>, <c>double</c>, and 
                                          <c>long</c>.</p>
                                    </feedback>
                                </condition>
                              </var>
                              </setup>
                              <hint><p>Some data types you could use are 
                                <c>byte</c>, <c>short</c>, <c>int</c>, <c>double</c>, and 
                                <c>long</c></p></hint>
                              </exercise>


</exercises>
  </subsection>
  <subsection xml:id="assignment-operators">
    <title>Assignment Operators</title>
    <p>
      In addition to the simple assignment
      operator (=), Java supplies a number of 
      shortcut assignment operators that allow you to 
      combine an arithmetic operation and an assignment in one operation.
      These operations can be used with either integer or floating-point operands.
      For example,
      the <c>+=</c> operator allows you to combine addition and assignment into one expression.
      The statement
    </p>
 <program language="java"><input>
k += 3;
 </input></program>
    <p>
      is equivalent to the statement
    </p>
 <program language="java"><input>
k = k + 3;
 </input></program>
    <p>
      Similarly, the statement
    </p>
 <program language="java"><input>
r += 3.5 + 2.0 * 9.3 ;
 </input></program>
    <p>
      is equivalent to
    </p>
 <program language="java"><input>
r = r + (3.5 + 2.0 * 9.3);  // i.e., r = r + 22.1;
 </input></program>
    <p>
      As these examples illustrate,
      when using the <c>+=</c> operator,
      the expression on its right-hand side is first evaluated and then <em>added</em>
      to the current value of the variable on its left-hand side.
    </p>
    <p>
      <xref ref="tab-assign">Table</xref> lists the other assignment operators that can 
      be used in combination with the arithmetic operators.
      For each of these operations,
      the interpretation is the same: Evaluate the expression on the 
      right-hand side of the operator and then perform the arithmetic operation
      (such as addition or multiplication)
      to the current value of the variable on the left of the operator.
    </p>
    <table xml:id="tab-assign">
      <title>Java's assignment operators assignment operators</title>
      <tabular>
        <row bottom="minor" left="minor">
          <cell>{Operator}</cell>
          <cell>{Operation}</cell>
          <cell>{Example}</cell>
          <cell>{Interpretation}</cell>
        </row>
        <row>
          <cell><m>=</m></cell>
          <cell><em>Simple assignment</em></cell>
          <cell><m>m = n;</m></cell>
          <cell><m>m = n;</m></cell>
        </row>
        <row>
          <cell><m>+\!=</m></cell>
          <cell><em>Addition then assignment</em></cell>
          <cell><m>m\ +\!=\ 3;</m></cell>
          <cell><m>m = m + 3;</m></cell>
        </row>
        <row>
          <cell><m>-\!=</m></cell>
          <cell><em>Subtraction then assignment</em></cell>
          <cell><m>m\ -\!=\ 3;</m></cell>
          <cell><m>m = m - 3;</m></cell>
        </row>
        <row>
          <cell><m>\ast \!=</m></cell>
          <cell><em>Multiplication then assignment</em></cell>
          <cell><m>m\ \ast \!=\ 3;</m></cell>
          <cell><m>m = m\,\ast \,3;</m></cell>
        </row>
        <row>
          <cell><m>/\!=</m></cell>
          <cell><em>Division then assignment</em></cell>
          <cell><m>m\ /\!=\ 3;</m></cell>
          <cell><m>m = m / 3;</m></cell>
        </row>
        <row bottom="minor">
          <cell><m>\%\!=</m></cell>
          <cell><em>Remainder then assignment</em></cell>
          <cell><m>m\ \%\!=\ 3;</m></cell>
          <cell><m>m = m \% 3;</m></cell>
        </row>
      </tabular>
    </table>
    <p>
 <!--     </subsection><subsection><title>Self-Study Exercises</title> -->
    </p>
  </subsection>
  <subsection xml:id="relationals">
    <title>Relational Operators</title>
    <p>
      There are several <em>relational</em>
      operations that can be performed on numbers:
      <m>\lt</m>, <m>></m>, <m>\lt =</m>,
      <m>> =</m>, <m>= =</m>, and <m>!\!=</m>.
      These correspond to the algebraic operators <m>\lt</m>,
      <m>></m>,
      <m>\leq</m>, <m>\geq</m>, <m>=</m>, and <m>\neq</m>.
      Each of these operators takes two operands
      (integer or real)
      and returns a boolean result.
      They are defined in <xref ref="tab-relations">Table</xref>.
    </p>
    <table xml:id="tab-relations">
      <title>Relational operators.</title>
      <tabular>
        <row bottom="minor" left="minor">
          <cell>{Operator}</cell>
          <cell>{Operation}</cell>
          <cell>{Java Expression}</cell>
        </row>
        <row>
          <cell><m>\lt</m></cell>
          <cell><em>Less than</em></cell>
          <cell><m>5 \lt   10</m></cell>
        </row>
        <row>
        <cell><m>></m></cell>
          <cell><em>Greater than</em></cell>
          <cell><m>10  >  5</m></cell>
        </row>
        <row>
          <cell><m>\lt  =</m></cell>
          <cell><em>Less than or equal to</em></cell>
          <cell><m>5 \lt  = 10</m></cell>
        </row>
        <row>
          <cell><m>> =</m></cell>
          <cell><em>Greater than or equal to</em></cell>
          <cell><m>10 > =  5</m></cell>
        </row>
        <row>
          <cell><m>= =</m></cell>
          <cell><em>Equal  to</em></cell>
          <cell><m>5 = = 5</m></cell>
        </row>
        <row bottom="minor">
          <cell><m>!\!=</m></cell>
          <cell><em>Not equal to</em></cell>
          <cell><m>5\ !\!=\ 4</m></cell>
        </row>
      </tabular>
    </table>
    <p>
      Note that several of these relational operators require two symbols in Java.
      Thus, the familiar equals sign (=) is replaced in Java by ==.  This is so the equality operator can be distinguished from the assignment operator.
      Also, less than or equal to (<m>\lt</m>=), greater than or equal to (<m>></m>=), and not equal to (!=) require two symbols,
      instead of the familiar <m>\leq</m>,
      <m>\geq</m>, and <m>\neq</m> from algebra.
      In each case, the two symbols should be consecutive.
      It is an error in Java for a space to appear between the <m>\lt</m> and = in <m>\lt =</m>.
    </p>
    <principle>
      <title>DEBUGGING TIP: Equality and Assignment</title>
      <p>
        A common semantic error among beginning programmers is to use the assignment operator (=) when the equality operator (==) is intended.
      </p>
    </principle>
    <p>
      Among the relational operators,
      the inequalities (<m>\lt</m>, <m>></m>, <m>\lt =</m>,
      and <m>> =</m>) have higher precedence than the equality operators
      (<m>= =</m> and <m>!\!=</m>).
      In an expression that involves both kinds of operators,
      the inequalities would be evaluated first.
      Otherwise, the expression is evaluated from left to right.
    </p>
    <p>
      Taken as a group the relational operators have lower precedence
          <idx><h>precedence</h></idx>
      than the arithmetic operators.
      Therefore, in evaluating an expression that involves both arithmetic and relational operators,
      the arithmetic operations are done first.
      <xref ref="tab-rel-precedence">Table</xref> includes all of the numeric operators introduced so<nbsp/>far.
    </p>
    <table xml:id="tab-rel-precedence">
      <title>Numeric operator precedence including relations</title>
      <tabular>
        <row bottom="minor" left="minor">
          <cell>Precedence Order</cell>
          <cell>Operator</cell>
          <cell>Operation</cell>
        </row>
        <row>
          <cell>1</cell>
          <cell><m>(\,)</m></cell>
          <cell><em>Parentheses</em></cell>
        </row>
        <row>
          <cell>2</cell>
          <cell><m>+\!+\ \ --</m></cell>
          <cell><em>Increment,  decrement</em></cell>
        </row>
        <row>
          <cell>3</cell>
          <cell><m>\ast \ \ /\ \ \%</m></cell>
          <cell><em>Multiplication,  division,  modulus</em></cell>
        </row>
        <row>
          <cell>4</cell>
          <cell><m>+\ \ -</m></cell>
          <cell><em>Addition,  subtraction</em></cell>
        </row>
        <row>
          <cell>5</cell>
          <cell><m>\lt \,\,\,\,>\ \ \lt  =\ \ > =</m></cell>
          <cell><em>Relational  operators</em></cell>
        </row>
        <row bottom="minor">
          <cell>6</cell>
          <cell><m>= =\ \ !\!=</m></cell>
          <cell><em>Equality  operators</em></cell>
        </row>
      </tabular>
    </table>
    <p>
      To take an example,
      let us evaluate the following complex expression:
    </p>
 <program language="java"><input>
9 + 6 &lt;= 25 * 4 + 2
 </input></program>
    <p>
      To clarify the implicit operator precedence,
      we first parenthesize the expression
    </p>
 <program language="java"><input>
( 9 + 6 ) &lt;= ( (25 * 4 ) + 2 )
 </input></program>
    <p>
      and then evaluate it step by step:
    </p>
 <program language="java"><input>
Step 1. ( 9 + 6 ) &lt;= ( (25 * 4 ) + 2 )
Step 2. ( 9 + 6 ) &lt;= ( 100 + 2 )
Step 3. 15 &lt;= 102
Step 4. true
 </input></program>
    <p>
      The following expression is an example of an ill-formed expression:
    </p>
 <program language="java"><input>
9 + 6 &lt;= 25 * 4 == 2
 </input></program>
    <p>
      That the expression is ill formed becomes obvious if we parenthesize it and then attempt to evaluate it:
    </p>
 <program language="java"><input>
Step 1. ( ( 9 + 6 )  &lt;= ( 25 * 4 ) ) == 2
Step 2. ( 15  &lt;= 100 ) == 2
Step 3. true == 2      // Syntax error results here
 </input></program>
    <p>
      The problem here is that the expression
<c>true == 2</c> is an attempt to compare an <c>int</c> and a
<c>boolean</c> value,
      which can't be done.
      As with any other binary operator,
      the == operator requires that both  of its operands be of the same type.
      This is another example of Java's strong type checking.
    </p>
    
  </subsection>    
</section>