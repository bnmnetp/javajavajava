<section xml:id="case-study-a-two-player-game-hierarchy">
  <title>Case Study: A Two Player Game Hierarchy</title>
  <introduction>
    <p>
      In this section we will redesign our <c>OneRowNim</c> game to fit within a 
      hierarchy of classes of two-player games, which might include checkers, chess, tic-tac-toe,
      guessing games, and so forth.

      <!--
      However, there are also many games that involve just 1 player:
      blackjack, solitaire, and others.
      There are also games that involve two or more players,
      such as many card games.
      Thus, our redesign of <c>OneRowNim</c> as part of a two-player game hierarchy 
      will not be our last effort to design a hierarchy of game-playing classes.
      We will certainly re-design things as we learn new Java language constructs and 
      as we try to extend our game library to other kinds of games.
      -->
    </p>
    <p>
      This case study will illustrate how we can apply inheritance and polymorphism,
      as well as other object-oriented design principles.
      The justification for revising <c>OneRowNim</c> is to make 
      it easier to design and develop other two-player games.
    </p>
    <p>
      As we have seen,
      one characteristic of class hierarchies is that more general attributes and methods 
      are defined in top-level classes.
      As one proceeds down the hierarchy,
      the methods and attributes become more specialized.
      Creating a subclass is a matter of specializing a given class.
    </p>
  </introduction>
  <subsection>
    <title>Design Goals</title>
    <p>
      One of our design goals is to revise the <c>OneRowNim</c> game so that it 
      fits into a hierarchy of two-player games.
      One way to do this is to generalize the <c>OneRowNim</c> game by creating a 
      superclass that contains those attributes and methods that are common to all two-player games.
    </p>
    <p>
      The superclass will define the most general and  generic elements of two-player games.
      All two-player games,
      including <c>OneRowNim</c>, will be defined as subclasses of this top-level 
      superclass and will inherit and possibly override its public and protected variables and methods.
      Also, our top-level class will contain certain abstract methods,
      whose implementations will be given in <c>OneRowNim</c> and other subclasses.
    </p>
    <p>
      A second goal is to design a class hierarchy that makes it possible for computers to play the game,
      as well as human users.
      Thus, for a given two-player game,
      it should be possible for two humans to play each other,
      or for two computers to play each other,
      or for a human to play against a computer.
      This design goal will require that our design exhibit a certain amount of flexibility.
      As we shall see,
      this is a situation in which Java interfaces will come in handy.
    </p>
    <p>
      Another important goal is to design a two-player game hierarchy that can easily be used 
      with a variety of different user interfaces,
      including command-line interfaces and GUIs.
      To handle this feature,
      we will develop Java interfaces to serve as interfaces between our two-player games and 
      various user interfaces.
    </p>
  </subsection>
  <subsection xml:id="two-player-game-class">
    <title>Designing the <c>TwoPlayerGame</c> Class</title>
    <p>
      To begin revising the design of the <c>OneRowNim</c> game,
      we first need to design a top-level class,
      which we will call the <c>TwoPlayerGame</c> class.
      What variables and methods belong in this class?
    </p>
    <p>
      One way to answer this question is to generalize our current version of <c>OneRowNim</c>
      by moving any variables and methods that apply to all two-player games 
      up to the <c>TwoPlayerGame</c> class.
      All subclasses of <c>TwoPlayerGame</c><mdash/>which includes the <c>OneRowNim</c> 
      class <mdash/>would inherit these elements.
      <xref ref="fig-onerownim">Figure</xref>
      shows the current design of <c>OneRowNim</c>. 

      <figure xml:id="fig-onerownim">
        <caption><p>One Row Nim Class</p></caption>
      <image width="40%" source="chptr08/onerownim.png"/>
   </figure>
    </p>
    <p>
      What variables and methods should we move up to the <c>TwoPlayerGame</c> class?
      Clearly, the class constants, <c>PLAYER_ONE</c> and <c>PLAYER_TWO</c>, 
      apply to all two-player games.
      These should be moved up.
      On the other hand,
      the <c>MAX_PICKUP</c> and <c>MAX_STICKS</c> constants apply just to the <c>OneRowNim</c> game.
      They should remain in the <c>OneRowNim</c> class.
    </p>
    <p>
      The <c>nSticks</c> instance variable is a variable that only applies to the <c>OneRowNim</c> game,
      but not to other two-player games.
      It should stay in the <c>OneRowNim</c> class.
      On the other hand,
      the <c>onePlaysNext</c> variable applies to all two-player games,
      so we will move it up to the <c>TwoPlayerGame</c> class.
    </p>
    <p>
      Because constructors are not inherited,
      all of the constructor methods  will remain in the <c>OneRowNim</c> class.
      The instance methods, <c>takeSticks()</c> and <c>getSticks()</c>, are 
      particular to <c>OneRowNim</c>, so they should remain there.
      However, the other methods, <c>getPlayer()</c>, <c>gameOver()</c>, <c>getWinner()</c>, 
      and <c>reportGameState()</c>, are methods that would be useful to all two-player games.
      Therefore these methods should be moved up to the superclass.
    </p>
    <p>
      Of course, while these methods can be defined in the superclass,
      some of the methods can only be implemented in subclasses.
      For example,
      the <c>reportGameState()</c> method reports the current state of the game,
      so it has to be implemented in <c>OneRowNim</c>. Similarly,
      the <c>getWinner()</c> method defines how the winner of the game is determined,
      a definition that can only occur in the subclass.
      Every two-player game needs methods such as these.
      Therefore, we will define these as abstract methods in the superclass.
      The intention is that <c>TwoPlayerGame</c> subclasses will provide 
      game-specific implementations for these methods.
    </p>
    <p>
      Given these considerations,
      we come up with the design shown in <xref ref="fig-twoplayergame">Figure</xref>.
      The design shown in this figure is much more complex than designs we have used in earlier chapters.
      However, the complexity comes from combining ideas already discussed in previous 
      sections of this chapter, so don't be put off by it.
    </p>
    <figure xml:id="fig-twoplayergame">
      <caption><c>TwoPlayerGame</c> is the
      superclass for <c>OneRowNim</c> and other two player games.</caption>
      <image width="85%" source="chptr08/twoplayergame.png"/>
    </figure>
    <p>
      To begin with,
      notice that we have introduced two Java interfaces into our design in 
      addition to the <c>TwoPlayerGame</c> superclass.
      As we will show,
      these interfaces lead to a more flexible design and one that can easily 
      be extended to incorporate new two-player games.
      Let's take each element of this design separately.
    </p>
  </subsection>
  <subsection>
    <title>The <c>TwoPlayerGame</c> Superclass</title>
    <p>
      The purpose of the <c>TwoPlayerGame</c> class is to serve as the superclass for all two-player games.
      Therefore, it should define those variables and methods that are shared by two-player games.
    </p>
    <p>
      The <c>PLAYER_ONE</c>, <c>PLAYER_TWO</c>, and <c>onePlaysNext</c> variables and 
      the <c>getPlayer()</c>, <c>setPlayer()</c>, and <c>changePlayer()</c> methods have 
      been moved up from the <c>OneRowNim</c> class.
      Clearly, these variables and methods apply to all two-player games.
    </p>
    <p>
      Note that we have also added three new variables: <c>nComputers</c>, <c>computer1</c>, 
      <c>computer2</c> and their corresponding methods, <c>getNComputers()</c> and <c>addComputerPlayer()</c>. 
      We will use these elements to give our games the ability to be played by computer programs.
      Because we want all of our two-player games to have this capability,
      we define these variables and methods in the superclass rather than in <c>OneRowNim</c> and 
      subclasses of <c>TwoPlayerGame</c>.
    </p>
    <p>
      Note that the <c>computer1</c> and <c>computer2</c> variables are declared to be of 
      type <c>IPlayer</c>. <c>IPlayer</c> is an interface,
      which contains a single method declaration,
      the <c>makeAMove()</c> method:
    </p>
 <program language="java"><input>
public interface IPlayer {
     public String makeAMove(String prompt);
 }
 </input></program>
    <p>
      <term>Why an interface?</term> Why do we use an interface here rather than 
      some type of game-playing object?
      This is a good design question.
      Using an interface here makes our design more flexible and extensible because it 
      frees us from having to know the names of the classes that implement the <c>makeAMove()</c> method.
      The variables <c>computer1</c> and <c>computer2</c> will be assigned objects that 
      implement <c>IPlayer</c> via the <c>addComputerPlayer()</c> method.
    </p>
    <p>
      The algorithms used in the various implementations of <c> makeAMove()</c> are
      <em>game-dependent</em><mdash/>they depend on the particular game being played.
      It would be impossible to define a game-playing object that would suffice for all two-player games.
      Instead, if we want an object that plays <c>OneRowNim</c>, we would define 
      a <c>OneRowNimPlayer</c> and have it implement the <c>IPlayer</c> interface.
      Similarly, if we want an object that plays checkers,
      we would define a <c>CheckersPlayer</c> and have it implement the <c>IPlayer</c> interface.
    </p>
    <p>  
      By using an interface here,
      our <c>TwoPlayerGame</c> hierarchy can deal with a wide range of  differently 
      named objects that play games,
      as long as they implement the <c>IPlayer</c> interface.
      So, using the <c>IPlayer</c> interface adds flexibility to our game hierarchy 
      and makes it easier to extend it to new,
      yet undefined, classes.
      We will discuss the details of how to design a game player in one of the following sections.
    </p>
  </subsection>
  <subsection>
    <title>Superclass Method Implementations</title>    
    <p>
      Turning now to the methods defined in <c>TwoPlayerGame</c>, we have already seen 
      implementations of <c>getPlayer()</c>, <c>setPlayer()</c>, and <c>changePlayer()</c> 
      in the <c>OneRowNim</c> class.
      We will just move those implementations up to the superclass.
      The <c>getNComputers()</c> method is the accessor method for the <c>nComputers</c> variable,
      and its implementation is routine.
      The <c>addComputerPlayer()</c> method adds a computer player to the game.
      Its implementation is as follows:
    </p>
 <program language="java"><input>
public void addComputerPlayer(IPlayer player) {
   if (nComputers == 0)
      computer2 = player;
   else if (nComputers == 1)
      computer1 = player;
   else
      return; // No more than 2 players
   ++nComputers;
}
 </input></program>
    <p>
      As we noted earlier,
      the classes that play the various <c>TwoPlayerGame</c>s must implement the <c>IPlayer</c> interface.
      The parameter for this method is of type <c>IPlayer</c>. The algorithm we use checks 
      the current value of <c>nComputers</c>. If it is 0, which means that this is the 
      first <c>IPlayer</c> added to the game,
      the <c>player</c> is assigned to <c>computer2</c>. This allows the human 
      user to be associated with <c>PLAYERONE</c>, if this is a game between a computer and a human user.
    </p>
    <p>
      If <c>nComputers</c> equals 1, which means that we are adding a second
      <c>IPlayer</c> to the game,
      we assign that <c>player</c> to <c>computer1</c>. In either of these cases,
      we increment <c>nComputers</c>. Note what happens if <c>nComputers</c> is neither 1 nor 2.
      In that case,
      we simply return without adding the <c>IPlayer</c> to the game and without 
      incrementing <c>nComputers</c>. This,
      in effect,
      limits the number of <c>IPlayer</c>s to two. (A more sophisticated design 
      would throw an exception to report an error. but we will leave that for a subsequent chapter.)
    </p>
    <p>
      The <c>addComputerPlayer()</c> method is used to initialize a game after it is first created.
      If this method is not called,
      the default assumption is that <c>nComputers</c> equals zero and that <c>computer1</c> 
      and <c>computer2</c> are both <c>null</c>. Here's an example of how it could be used:
    </p>
 <program language="java"><input>
 OneRowNim nim = new OneRowNim(11); // 11 sticks
 nim.add(new NimPlayer(nim));       // 2 computer players
 nim.add(new NimPlayerBad(nim));
 </input></program>
    <p>
      Note that the <c>NimPlayer()</c> constructor takes a reference to the game as its argument.
      Clearly, our design should not assume that the names of the <c>IPlayer</c> objects 
      would be known to the <c>TwoPlayerGame</c> superclass.
      This method allows the objects to be passed in at run time.
      We will discuss the details of <c>NimPlayerBad</c> in a subsequent section.
    </p>
    <p>
      The <c>getRules()</c> method is a new method whose purpose is to return  
      a string that describes the rules of the particular game.
      This method is implemented in the <c>TwoPlayerGame</c> class with the intention 
      that it will be overridden in the various subclasses.
      For example,
      its implementation in <c>TwoPlayerGame</c> is:
    </p>
 <program language="java"><input>
public String getRules() {
     return "The rules of this game are: ";
 }
 </input></program>
    <p>
      and its redefinition in <c>OneRowNim</c> is:
    </p>
 <program language="java"><input>
public String getRules() {
  return "\n*** The Rules of One Row Nim ***\n" +
  "(1) A number of sticks between 7 and " + MAX_STICKS +
          " is chosen.\n" +
  "(2) Two players alternate making moves.\n" +
  "(3) A move consists of subtracting between 1 and\n\t" +
  MAX_PICKUP +
  " sticks from the current number of sticks.\n" +
  "(4) A player who cannot leave a positive\n\t" +
  " number of sticks for the other player loses.\n";
}
 </input></program>
    <p>
      The idea is that each <c>TwoPlayerGame</c> subclass will take responsibility 
      for specifying its own set of rules in a form that can be displayed to the user.
    </p>
    <p>
      You might recognize that defining <c>getRules()</c> in the superclass and 
      allowing it to be overridden in the subclasses is a form of  polymorphism.
      It follows the design of the <c>toString()</c> method,
      which we discussed earlier.
      This design will allow us to use code that takes the following form:
    </p>
 <program language="java"><input>
TwoPlayerGame game = new OneRowNim();
  System.out.println(game.getRules());
 </input></program>
    <p>
      In this example the call to <c>getRules()</c> is polymorphic.
      The dynamic binding mechanism is used to invoke the <c>getRules()</c> method 
      that is defined in the <c>OneRowNim</c> class.
    </p>
  </subsection>
  <subsection>
    <title>Superclass Abstract Method</title>      
    <p>
      The remaining methods in <c>TwoPlayerGame</c> are defined abstractly.
      The <c>gameOver()</c> and <c>getWinner()</c> methods are both methods that are
      <em>game dependent</em>.
      That is, the details of their implementations depend on the particular 
      <c>TwoPlayerGame</c> subclass in which they are implemented.
    </p>
    <p>
      This is good example of how abstract methods should be used in designing a class hierarchy.
      We give abstract definitions in the superclass and leave the detailed implementations up to the individual subclasses.
      This allows the different subclasses to tailor the implementations to their particular needs,
      while allowing all subclasses to share a common signature for these tasks.
      This allows us to use polymorphism to create flexible,
      extensible class hierarchies.
    </p>
    <principle>
      <title>EFFECTIVE DESIGN: Abstract Methods</title>
      <p>
        Abstract methods allow you to give general definitions in the superclass 
        and to leave the implementation details to the different subclasses.
      </p>
    </principle>
  </subsection>
  <subsection>
    <title>The  <c>TwoPlayerGame</c> Implementation</title> 
    <p>
      <xref ref="fig-twoplayercode">Listing</xref>
      shows the complete implementation of the abstract <c>TwoPlayerGame</c> class.
      We have already discussed the most important details of its implementation.
    </p>
    
    <listing xml:id="fig-twoplayercode">
      <caption>The <c>TwoPlayerGame</c> class</caption>
 <program language="java"><input>
public abstract class TwoPlayerGame {
  public static final int PLAYER_ONE = 1;
  public static final int PLAYER_TWO = 2;
  protected boolean onePlaysNext = true;
  protected int nComputers = 0;     // How many computers
                                // Computers are IPlayers
  protected IPlayer computer1, computer2;
  public void setPlayer(int starter) {
    if (starter == PLAYER_TWO)
      onePlaysNext = false;
    else onePlaysNext = true;
  } //setPlayer()
  public int getPlayer() {
    if (onePlaysNext)
      return PLAYER_ONE;
    else return PLAYER_TWO;
  } //getPlayer()
  public void changePlayer() {
    onePlaysNext = !onePlaysNext;
  } //changePlayer()
  public int getNComputers() {
    return nComputers;
  }
  public String getRules() {
    return "The rules of this game are: ";
  }
  public void addComputerPlayer(IPlayer player) {
    if (nComputers == 0)
      computer2 = player;
    else if (nComputers == 1)
      computer1 = player;
    else
      return;  // No more than 2 players
    ++nComputers;
  }
    public abstract boolean gameOver();// Abstract Methods
    public abstract String getWinner();
 } //TwoPlayerGame
 </input></program>
</listing>
  </subsection>

  <subsection>
    <title>The <c>CLUIPlayableGame</c> Interface</title>
    <p>
      Let's turn now to the two interfaces shown in <xref ref="fig-twoplayergame">Figure</xref>.
      Taken together,
      the purpose of these interfaces is to create a connection between any two-player game 
      and a <term>command-line user interface (CLUI)</term>.
      The interfaces provide method signatures for the methods that will implement the details 
      of the interaction between a <c>TwoPlayerGame</c> and a <c>UserInterface</c>. Because the 
      details of this interaction vary from game to game,
      it is best to leave the implementation of these methods to the games themselves.
    </p>
    <p>
      Note that <c>CLUIPlayableGame</c> extends the <c>IGame</c> interface.  
      The <c>IGame</c> interface contains two methods that are used to define a standard 
      form of communication between the CLUI and the game.
      The <c>getGamePrompt()</c> method defines the prompt that is used to signal the user for 
      some kind of move<mdash/>for example,
      <q>How many sticks do you take (1, 2, or 3)?</q>
      And the <c>reportGameState()</c> method defines how that particular game will 
      report its current state<mdash/>for example,
      <q>There are 11 sticks remaining.</q>
       <c>CLUIPlayableGame</c> adds the <c>play()</c> method to these two methods.
      As we will see shortly, the <c>play()</c> method will contain the code that will 
      control the playing of the game.
    </p>
    <p>
      The source code for these interfaces is very simple:
    </p>
 <program language="java"><input>
public interface CLUIPlayableGame extends IGame {
    public abstract void play(UserInterface ui);
} 

public interface IGame {
    public String getGamePrompt();
    public String reportGameState();
} 
 </input></program>
    <p>
      Notice that the <c>CLUIPlayableGame</c> interface extends the <c>IGame</c> interface.
      A <c>CLUIPlayableGame</c> is a game that can be played through a CLUI. The 
      purpose of its <c>play()</c> method is to contain the <em>game dependent</em>
      control loop that determines how the game is played via some kind of user interface (UI).
      In pseudocode, a typical control loop for a game would look something like the following:
    </p>
    <p>    
    </p>
 <algorithm>
 <program language="java"><input>
Initialize the game.
While the game is not over
  Report the current state of the game via the UI.
  Prompt the user (or the computer) to make a move via the UI.
  Get the user's move via the UI.
  Make the move.
  Change to the other player.
</input></program>
 </algorithm>>
    <p>
      The play loop sets up an interaction between the game and the UI. The <c>UserInterface</c> 
      parameter allows the game to connect directly to a particular UI. To allow us to play 
      our games through a variety of UIs, we define <c>UserInterface</c> as the following Java interface:
    </p>
 <program language="java"><input>
public interface UserInterface {
     public String getUserInput();
     public void report(String s);
     public void prompt(String s);
 }
 </input></program>
    <p>
      Any object that implements these three methods can serve as a UI for one of our <c>TwoPlayerGame</c>s.
      This is another example of the flexibility of using interfaces in object-oriented design.
    </p>
    <p>
      To illustrate how we use <c>UserInterface</c>, let's attach it to our
      <c>KeyboardReader</c> class, thereby letting a <c>KeyboardReader</c> serve as a CLUI 
      for <c>TwoPlayerGame</c>s.
      We do this simply by implementing this interface in the <c>KeyboardReader</c> class,
      as follows:
    </p>
 <program language="java"><input>
public class KeyboardReader implements UserInterface
 </input></program>
    <p>
      As it turns out,
      the three methods listed in <c>UserInterface</c> match three of the methods 
      in the current version of <c>KeyboardReader</c>. This is no accident.
      The design of <c>UserInterface</c> was arrived at by identifying the minimal number of 
      methods in <c>KeyboardReader</c> that were needed to interact with a <c>TwoPlayerGame</c>.
    </p>
    <principle>
      <title>EFFECTIVE DESIGN: Flexibility of Java Interfaces</title>
      <p>
        A Java interface provides a means of associating useful methods with a variety of different types of objects,
        leading to a more flexible object-oriented design.
      </p>
    </principle>
    <p>
      The benefit of defining the parameter more generally as a <c>UserInterface</c>, 
      instead of as a <c>KeyboardReader</c>, is that we will eventually want to allow 
      our games to be played via other kinds of command-line interfaces.
      For example,
      we might later define an Internet-based CLUI that could be used to play 
      <c>OneRowNim</c> among users on the Internet.
      This kind of extensibility <mdash/> the ability to create new kinds of UIs and 
      use them with <c>TwoPlayerGame</c>s <mdash/> is another important design feature of Java interfaces.
    </p>
    <principle>
      <title>EFFECTIVE DESIGN:Extensibility and  Java Interfaces</title>
      <p>
        Using interfaces to define useful method signatures increases the extensibility of a class hierarchy.
      </p>
    </principle>
    <p>
      As <xref ref="fig-twoplayergame">Figure</xref>
      shows, <c>OneRowNim</c> implements the <c>CLUIPlayableGame</c> interface,
      which means it must supply implementations of all three abstract methods: <c>play()</c>, 
      <c>getGamePrompt()</c>, and <c>reportGameState()</c>.
    </p>
  </subsection>
  <subsection>
    <title>Object Oriented Design: Interfaces or Abstract Classes</title>
    <p>
      Why are these methods defined in interfaces?
      Couldn't we just as easily define them in the <c>TwoPlayerGame</c> class and use 
      inheritance to extend them to the various game subclasses?
      After all, isn't the net result the same, namely,
      that <c>OneRowNim</c> must implement all three methods.
    </p>
    <p>
      These are very good design questions,
      exactly the kinds of questions  one should ask when designing a class hierarchy of any sort.
      As we pointed out in the <c>Animal</c> example earlier in the chapter,
      you can get the same functionality from an abstract interface and from an abstract superclass method.
      When should we put the abstract method in the superclass and when does it belong in an interface?
    </p>
    <p>
      A very good discussion of these and related object-oriented design issues is available in
      <em>Java Design, 2nd Edition</em>,
      by Peter Coad and Mark Mayfield (Yourdan Press, 1999).
      Our discussion of these issues follows many of the guidelines suggested by Coad and Mayfield.
    </p>
    <p>
      We have already seen that using Java interfaces increases the flexibility and extensibility of a design.
      Methods defined in an interface exist independently of a particular class hierarchy.
      By their very nature, interfaces can be attached to any class,
      which  makes them very flexible to use.
    </p>
    <p>
      Another useful guideline for answering this question is that the superclass should contain the 
      basic common attributes and methods that define a certain type of object.
      It should not necessarily contain methods that define certain
      <em>roles</em> that the object plays.
      For example,
      the <c>gameOver()</c> and <c>getWinner()</c> methods are fundamental parts of the 
      definition of a <c>TwoPlayerGame</c>. One cannot define a game without defining these methods.
      By contrast,
      methods such as <c>play()</c>, <c>getGamePrompt()</c>, and <c>reportGameState()</c> are 
      important for playing the game but they do not contribute in the same way to the game's definition.
      Thus these methods are best put into an interface.
      So, one important design guideline is:
    </p>
    <principle>
      <title>EFFECTIVE DESIGN: Abstract Methods</title>
      <p>
        Methods defined abstractly in a superclass should contribute in a fundamental 
        way toward the basic definition of that type of object,
        not merely toward one of its roles or its functionality.
      </p>
    </principle>
  </subsection>
  <subsection>
    <title>The Revised <c>OneRowNim</c>Class</title>
    <p>
      <xref ref="fig-revisednim2">Listing</xref>
      provides a listing of the revised <c>OneRowNim</c> class,
      one that fits into the <c>TwoPlayerGame</c> class hierarchy.
      Our discussion in this section will focus on just those features of the game that are new or revised.
    </p>
    <listing xml:id="fig-revisednim2">
      <caption>The revised  <c>OneRowNim</c> class</caption>
      
 <program language="java"><input>
public class OneRowNim extends TwoPlayerGame implements CLUIPlayableGame {
  public static final int MAX_PICKUP = 3;
  public static final int MAX_STICKS = 11;
  private int nSticks = MAX_STICKS;

  public OneRowNim() { }            // Constructors
  public OneRowNim(int sticks) {
    nSticks = sticks;
  }  // OneRowNim()
  public OneRowNim(int sticks, int starter) {
    nSticks = sticks;
    setPlayer(starter);
  } // OneRowNim()
  
  public boolean takeSticks(int num) {
    if (num &lt; 1 || num > MAX_PICKUP || num > nSticks)
      return false;                  // Error
    else                             // Valid move
    {   nSticks = nSticks - num;
        return true;
    } //else
  } // takeSticks()

  public int getSticks() {
    return nSticks;
  } // getSticks()
  
  public String getRules() {
    return "\n*** The Rules of One Row Nim ***\n" +
    "(1) A number of sticks between 7 and " + MAX_STICKS +
         " is chosen.\n" +
    "(2) Two players alternate making moves.\n" +
    "(3) A move consists of subtracting between 1 and\n\t" +
        MAX_PICKUP + " sticks from the current number of sticks.\n" +
    "(4) A player who cannot leave a positive\n\t" +
    " number of sticks for the other player loses.\n";
  } // getRules()
  
  public boolean gameOver() {   /** From TwoPlayerGame */
    return (nSticks &lt;= 0);
  }  // gameOver()
  
  public String getWinner()  {       /** From TwoPlayerGame */
    if (gameOver()) //{
      return "" + getPlayer() + " Nice game.";
    return "The game is not over yet.";   // Game is not over
  } // getWinner()
 
  /** From CLUIPlayableGame */
  public String getGamePrompt() {
    return "\nYou can pick up between 1 and " +
                    Math.min(MAX_PICKUP,nSticks) + " : ";
  } // getGamePrompt()
  
  public String reportGameState() {
    if (!gameOver())
       return ("\nSticks left: " + getSticks() +
          " Who's turn: Player " + getPlayer());
    else
       return ("\nSticks left: " + getSticks() +
        " Game over! Winner is Player "  + getWinner() +"\n");
  }   // reportGameState()
  
  public void play(UserInterface ui) {  // From CLUIPlayableGame interface
    int sticks = 0;
    ui.report(getRules());
    if (computer1 != null)
      ui.report("\nPlayer 1 is a " + computer1.toString());
    if (computer2 != null)
      ui.report("\nPlayer 2 is a " + computer2.toString());
    while(!gameOver()) {
      IPlayer computer = null;     // Assume no computers
      ui.report(reportGameState());
      switch(getPlayer()) {
      case PLAYER_ONE:             // Player 1's turn
        computer = computer1;
        break;
      case PLAYER_TWO:             // Player 2's turn
        computer = computer2;
        break;
      } // cases
      if (computer != null) {      // If computer's turn
        sticks = Integer.parseInt(computer.makeAMove(""));
        ui.report(computer.toString() + " takes " +
                                   sticks + " sticks.\n");
      } else {                  // otherwise, user's turn
        ui.prompt(getGamePrompt());
        sticks =
          Integer.parseInt(ui.getUserInput()); // Get user's move
      }
      if (takeSticks(sticks))      // If a legal move
        changePlayer();
    } // while
    ui.report(reportGameState());  // The game is now over
  } // play()
} // OneRowNim class
 </input></program>
</listing>
    <p>
      The <c>gameOver()</c> and <c>getWinner()</c> methods,
      which are now inherited from the <c>TwoPlayerGame</c> superclass,
      are virtually the same as in the previous version.
      One small change is that <c>getWinner()</c> now returns a <c>String</c> instead of 
      an <c>int</c>. This makes that method more generally useful as a way of identifying 
      the winner for all <c>TwoPlayerGame</c>s.
    </p>
    <p>
      Similarly, the <c>getGamePrompt()</c> and <c>reportGameState()</c> methods merely encapsulate 
      functionality that was present in the earlier version of the game.
      In our earlier version the prompts to the user were generated directly by the main program.
      By encapsulating  this information in an inherited method,
      we make it more generally useful to all TwoPlayerGames.
    </p>
    <p>
      The major change to <c>OneRowNim</c> comes in the <c>play()</c> method (<xref ref="orn-play"></xref>),
      which controls the playing of the <c>OneRowNim</c>.
      Because this version of the game incorporates computer players,
      the play loop is a bit more complex than in earlier versions of the game.
      The basic idea is still the same: The method loops until the game is over.
      On each iteration of the loop,
      one or the other of the two players, <c>PLAYER_ONE</c> or <c>PLAYER_TWO</c>, takes a turn 
      making a move <mdash/> that is,
      deciding how many sticks to pick up.
      If the move is a legal move, then it becomes the other player's turn.
    </p>
<listing xml:id="orn-play">
<caption>The <c>play()</c> method controls the game.</caption>
 <program language="java"><input>
  public void play(UserInterface ui) {  // From CLUIPlayableGame interface
    int sticks = 0;
    ui.report(getRules());
    if (computer1 != null)
      ui.report("\nPlayer 1 is a " + computer1.toString());
    if (computer2 != null)
      ui.report("\nPlayer 2 is a " + computer2.toString());
    while(!gameOver()) {
      IPlayer computer = null;     // Assume no computers
      ui.report(reportGameState());
      switch(getPlayer()) {
      case PLAYER_ONE:             // Player 1's turn
        computer = computer1;
        break;
      case PLAYER_TWO:             // Player 2's turn
        computer = computer2;
        break;
      } // cases
      if (computer != null) {      // If computer's turn
        sticks = Integer.parseInt(computer.makeAMove(""));
        ui.report(computer.toString() + " takes " +
                                   sticks + " sticks.\n");
      } else {                  // otherwise, user's turn
        ui.prompt(getGamePrompt());
        sticks =
          Integer.parseInt(ui.getUserInput()); // Get user's move
      }
      if (takeSticks(sticks))      // If a legal move
        changePlayer();
    } // while
    ui.report(reportGameState());  // The game is now over
  } // play()
 </input></program>
</listing>
    <p>
      Let's look now at how the code distinguishes between whether it is a 
      computer's turn to move or a human player's turn.
      Note that at the beginning of the <c>while</c> loop,
      it sets the <c>computer</c> variable to null.
      It then assigns <c>computer</c> a value of either <c>computer1</c> or <c>computer2</c>, 
      depending on whose turn it is.
      But recall that one or both of these variables may be <c>null</c>, depending on how many 
      computers are playing the game.
      If there are no computers playing the game,
      then both variables will be null.
      If only one computer is playing,
      then <c>computer1</c> will be null.
      This is determined during initialization of the game,
      when the <c>addComputerPlayer()</c> is called.
      (See above.)
    </p>
    <p>
      In the code following the <c>switch</c> statement,
      if <c>computer</c> is not <c>null</c>, then we call <c>computer.makeAMove()</c>. As we know,
      the <c>makeAMove()</c> method is part of the <c>IPlayer</c> interface.
      The <c>makeAMove()</c> method takes a <c>String</c> parameter that is meant to serve as a prompt,
      and returns a <c>String</c> that is meant to represent the <c>IPlayer</c>'s move:
    </p>
 <program language="java"><input>
public interface IPlayer {
     public String makeAMove(String prompt);
 }
 </input></program>
    <p>
      In <c>OneRowNim</c> the
      <q>move</q>
      is an integer,
      representing the number of sticks the player picks.
      Therefore, in <c>play()</c><c>OneRowNim</c> has to convert the <c>String</c> 
      into an <c>int</c>, which represents the number of sticks the <c>IPlayer</c> picks up.
    </p>
    <p>
      On the other hand,
      if <c>computer</c> is <c>null</c>, this means that it is a human user's turn to play.
      In this case, <c>play()</c> calls <c>ui.getUserInput()</c>, employing the user 
      interface to input a value from the keyboard.
      The user's input must also be converted from <c>String</c> to <c>int</c>. Once the value of <c>sticks</c> is set,
      either from the user or from the <c>IPlayer</c>, the <c>play()</c> 
      method calls <c>takeSticks()</c>. If the move is legal,
      then it changes whose turn it is, and the loop repeats.
    </p>
    <p>
      There are a couple of important points to notice about the design of  the <c>play()</c> method.
      First, the <c>play()</c> method has to know what to do with the input it receives 
      from the user or the <c>IPlayer</c>. This is game-dependent knowledge.
      The user is inputting the number of sticks to take in <c>OneRowNim</c>. For a tic-tac-toe game, the
      <q>move</q>
      might represent a square on the tic-tac-toe board.
      This suggests that <c>play()</c> is a method that should be implemented in <c>OneRowNim</c>, as it is here,
      because <c>OneRowNim</c> encapsulates the knowledge of how to play the One Row Nim game.
    </p>
    <p>
      A second point is to notice that the method call <c>computer.makeAMove()</c> is another 
      example of polymorphism at work.  The <c>play()</c> method does not know what type of 
      object the <c>computer</c> is, other than that it is an <c>IPlayer</c> <mdash/> that is,
      an object that implements the <c>IPlayer</c> interface.
  <!--
      As we will show in the next section,
      the <c>OneRowNim</c> game can be played by two different <c>IPlayer</c>s:
      one named <c>NimPlayer</c> and another named
      <c>NimPlayerBad</c>. Each has its own game-playing strategy,
      as implemented by their own versions of the <c>makeAMove()</c> method.
 -->
      Java uses dynamic binding to decide which version of <c>makeAMove()</c> to invoke 
      depending on the type of <c>IPlayer</c> whose turn it is.
      This use of polymorphism makes it possible to test different game-playing strategies against each other.
    </p>
  </subsection>
  <subsection>
    <title>The <c>IPlayer</c>Interface</title>
    <p>
      The last element of our design is the <c>IPlayer</c> interface, which,
      as we just saw,
      consists of the <c>makeAMove()</c> method.
      To see how we use this interface,
      let's design a class to play the game of <c>OneRowNim</c>. We will call the class
       <c>NimPlayerBad</c> and give it a very weak playing strategy.
      For each move it will pick a random number between 1 and 3, or between 1 and the total number of sticks left,
      if there are fewer than 3 sticks.
      (We will leave the task of defining <c>NimPlayer</c>, a good player,
      as an exercise.)
    </p>
      <figure xml:id="fig-nimplayerbad">
      <caption><p>NimPlayerBad Class</p></caption>
      <image width="50%" source="chptr08/nimplayer.png"/>
      </figure>
    <p>
      As an implementer of the <c>IPlayer</c> interface, <c>NimPlayerBad</c> 
      (<xref ref="fig-nimplayerbad">Fig</xref>) will implement the <c>makeAMove()</c> method.
      This method will contain <c>NimPlayerBad</c>'s strategy (algorithm) for playing the game.
      The result of this strategy will be the number of sticks that the player will pick up.
    </p>
    <p>
      What other elements
      (variables and methods)
      will a <c>NimPlayerBad</c> need?
      Clearly, in order to play <c>OneRowNim</c>, the player must know the rules and the current state of the game.
      The best way to achieve this is to give the Nim player a reference to the <c>OneRowNim</c> game.
      Then it can call <c>getSticks()</c> to determine how many sticks are left,
      and it can use other public elements of the <c>OneRowNim</c> game.
      Thus, we will have a variable of type <c>OneRowNim</c>, and we will assign it a value in a constructor method.
    </p>
    <p>
      <xref ref="fig-nimbad">Figure</xref>  shows the design of <c>NimPlayerBad</c>. 
      Note that we have added an implementation of the <c>toString()</c> method.
      This will be used to give a string representation of the <c>NimPlayerBad</c>. Also,
      note that we have added a private helper method named <c>randomMove()</c>, which 
      will simply generate an appropriate random number of sticks as the player's move.
    </p>
    <listing xml:id="fig-nimbad">
      <caption><c>NimPlayerBad</c> has no strategy and just makes random moves.</caption>
      
 <program language="java"><input>
public class NimPlayerBad implements IPlayer {
  private OneRowNim game;

  public NimPlayerBad (OneRowNim game) {
    this.game = game;
  } // NimPlayerBad()

  public String makeAMove(String prompt) {
    return "" + randomMove();
  } // makeAMove()

  private int randomMove() {
    int sticksLeft = game.getSticks();
    return 1 + (int)(Math.random() *
           Math.min(sticksLeft, game.MAX_PICKUP));
  } // randomMove()

  public String toString() {
    String className =
        this.getClass().toString(); // Gets 'class NimPlayerBad'
    return className.substring(5);  // Cut off the word 'class'
  } // toString()

} // NimPlayerBad
 </input></program>
</listing>
    <p>
      The implementation of <c>NimPlayerBad</c> is shown in <xref ref="fig-nimbad">Listing</xref>.
      The <c>makeAMove()</c> method converts the <c>randomMove()</c> to a <c>String</c> and returns it,
      leaving it up to <c>OneRowNim</c>, the calling object,
      to convert that move back into an <c>int</c>. Recall the statement in <c>OneRowNim</c> 
      where <c>makeAMove()</c> is invoked:
    </p>
 <program language="java"><input>
sticks = Integer.parseInt(computer.makeAMove(""));
 </input></program>
    <p>
      In this context,
      the <c>computer</c> variable,
      which is of type <c>IPlayer</c>, is bound to a <c>NimPlayerBad</c> object.
      In order for this interaction between the game and a player to work,
      the <c>OneRowNim</c> object must know what type of data is being returned by <c>NimPlayerBad</c>. 
      This is a perfect use for a Java interface,
      which specifies the signature of <c>makeAMove()</c> without committing to any particular 
      implementation of the method.
      Thus, the association between <c>OneRowNim</c> and <c>IPlayer</c> provides a flexible and 
      effective model for this type of interaction.
    </p>
    <principle>
      <title>EFFECTIVE DESIGN: Interface Associations</title>
      <p>
        Java interfaces provide a flexible way to set up associations between two different types of objects.
      </p>
    </principle>
    <p>
      Finally, note the details of the <c>randomMove()</c> and <c>toString()</c> methods.
      The only new thing here is the use of the <c>getClass()</c> method in <c>toString()</c>. 
      This is a method that is defined in the <c>Object</c> class and inherited by all Java objects.
      It returns a <c>String</c> of the form
      <q>class X</q>
      where <em>X</em> is the name of that object's class.
      Note here that we are removing the word
      <q>class</q>
      from this string before returning the class name.
      This allows our <c>IPlayer</c> objects to report what type of players they are,
      as in the following statement from <c>OneRowNim</c>:
    </p>
 <program language="java"><input>
ui.report("\nPlayer 1 is a " + computer1.toString());
 </input></program>
    <p>
      If <c>computer1</c> is a <c>NimPlayerBad</c>, it would report
      <q>Player1 is a NimPlayerBad.</q>
    </p>
    <p>Try NimPlayerBad in the exercise below.</p>        

</subsection>

   <subsection>
    <title>Playing <c>OneRowNim</c></title>
    <p>
      Let's now write a <c>main()</c> method to play <c>OneRowNim</c>:
    </p> 
    <p>
      
    </p>
 <program language="java"><input>
     public static void main(String args[]) {
        KeyboardReader kb = new KeyboardReader();
        CLUIPlayableGame game = new OneRowNim();

        kb.prompt("How many computers are playing, 0, 1, or 2? ");
        int m = kb.getKeyboardInteger();
        for (int k = 0; k &lt; m; k++) {
            IPlayer computer = new NimPlayerBad((OneRowNim) game);
            ((TwoPlayerGame) game).addComputerPlayer(computer);
        }
        game.play(kb);
    } // main()
 </input></program>
    <p>
      After creating a <c>KeyboardReader</c> and then creating an instance of <c>OneRowNim</c>, we 
      prompt the user to determine how many computers are playing.
      We then repeatedly prompt the user to identify the names of the <c>IPlayer</c> 
      and use the <c>addComputerPlayer()</c> method to initialize the game.
      Finally, we get the game started by invoking the <c>play()</c> method,
      passing it a reference to the <c>KeyboardReader</c>, our <c>UserInterface</c>.
    </p>
    <p>
      Note that in this example we have declared a <c>OneRowNim</c> variable to represent the game.
      This is not the only way to do things.
      For example,
      suppose we wanted to write a <c>main()</c> method that could be used to play a 
      variety of different <c>TwoPlayerGame</c> s.
      Can we  make this code more general?
      That is, can we rewrite it to work with any <c>TwoPlayerGame</c>?
    </p>
    <p>
      A <c>OneRowNim</c> object is also a <c>TwoPlayerGame</c>, by virtue of inheritance,
      and it is also a <c>CLUIPlayableGame</c>, by virtue of implementing that interface.
      Therefore, we can use either of these types to represent the game.
      Thus, one alternative way of coding this is as follows:
    </p>
 <program language="java"><input>
    TwoPlayerGame game = new OneRowNim();
    ...
    IPlayer computer = new NimPlayer((OneRowNim)game);
    ...
    ((CLUIPlayableGame)game).play(kb);
 </input></program>
    <p>
      Here we use a <c>TwoPlayerGame</c> variable to represent the game.
      However, note that we now have to use a cast expression, <c>(CLUIPlayableGame)</c>, in order 
      to call the <c>play()</c> method.
      If we don't cast <c>game</c> in this way, Java will generate the following syntax error:
    </p>
 <program language="java"><input>
 OneRowNim.java:126: cannot resolve symbol
 symbol  : method play (KeyboardReader)
 location: class TwoPlayerGame
        game.play(kb);
           ^
 </input></program>
    <p>
      The reason for this error is that <c>play()</c> is not a method in the 
      <c>TwoPlayerGame</c> class,
      so the compiler cannot find the <c>play()</c> method.
      By using the cast expression,
      we are telling the compiler to consider <c>game</c> to be a <c>CLUIPlayableGame</c>. 
      That way it will find the <c>play()</c> method.
      Of course, the object assigned to <c>nim</c> must actually implement the
      <c>CLUIPlayableGame</c> interface in order for this to work at run time.
      We also need a cast operation in the <c>NimPlayer()</c> constructor in order to 
      make the argument (<c>computer</c>) compatible with that method's parameter.
    </p>
    <p>
      Another alternative for the <c>main()</c> method would be the following:
    </p>
 <program language="java"><input>
 CLUIPlayableGame game = new OneRowNim();
 ...
 IPlayer computer = new NimPlayer((OneRowNim)game);
 ((TwoPlayerGame)game).addComputerPlayer(computer);
 ...
 game.play(kb);
  nim.play(kb);
 </input></program>
    <p>
      By representing the game as a <c>CLUIPlayableGame</c> variable,
      we don't need the cast expression to call
      <c>play()</c>, but we do need a different cast expression, <c>(TwoPlayerGame)</c>, to 
      invoke <c>addComputerPlayer()</c>. Again,
      the reason is that the compiler cannot find the <c>addComputerPlayer()</c> method in 
      the <c>CLUIPlayableGame</c> interface,
      so we must tell it to consider <c>game</c> as a <c>TwoPlayerGame</c>, which of course it is.
      We still need the cast operation for the call to the <c>NimPlayer()</c> constructor.
    </p>
    <p>
      All three of the code options that we have considered will generate something like
      the interactive session shown in <xref ref="fig-playnim">Listing</xref>
      for a game in which two <c>IPlayer</c>s play each other.
    </p>
    <listing xml:id="fig-playnim">
      <caption>A typical run of the <c>OneRowNim</c> using a command-line
      user interface.</caption>
 <program language="java"><input>
How many computers are playing, 0, 1, or 2? 2

*** The Rules of One Row Nim ***
(1) A number of sticks between 7 and 11 is chosen.
(2) Two players alternate making moves.
(3) A move consists of subtracting between 1 and
	3 sticks from the current number of sticks.
(4) A player who cannot leave a positive
	 number of sticks for the other player loses.

Player 1 is a  NimPlayerBad
Player 2 is a  NimPlayerBad
Sticks left: 11 Who's turn: Player 1 NimPlayerBad takes 3 sticks.
Sticks left: 8 Who's turn: Player 2 NimPlayerBad takes 2 sticks.
Sticks left: 6 Who's turn: Player 1 NimPlayerBad takes 1 sticks.
Sticks left: 5 Who's turn: Player 2 NimPlayerBad takes 1 sticks.
Sticks left: 4 Who's turn: Player 1 NimPlayerBad takes 1 sticks.
Sticks left: 3 Who's turn: Player 2 NimPlayerBad takes 2 sticks.
Sticks left: 1 Who's turn: Player 1 NimPlayerBad takes 1 sticks.
Sticks left: 0 Game over! Winner is Player 2 Nice game.
 </input></program>
</listing>
    <p>
      Given our object-oriented design for the <c>TwoPlayerGame</c> hierarchy,
      we can now write generalized code that can play any <c>TwoPlayerGame</c> that 
      implements the <c>CLUIPlayableGame</c> interface.
      We will give a specific example of this in the next section.
    </p>

  <exercises>
  <title>Self-Study Exercises</title>
      
           
<exercise label="badnim-ex">
  <title>Improved One Row Nim</title>
  <statement>
    <p>The complete code for our revised <c>OneRowNim</c> is given here, including
      <c>NimPlayerBad</c> and the <c>main()</c> we just developed.
    </p>
    <p>Run it in the replit window below to see how it works. You can play
      against <c>NimPlayerBad</c> to develop a strategy.
      Then, add a class <c>NimPlayer</c> (using NimPlayerBad as a guide) that plays 
      the optimal strategy for <c>OneRowNim</c>. This strategy was described in Chapter<nbsp/>5.
    </p>
<program language="java" interactive="activecode">
<input>
import java.io.*;
/*
 * OneRowNim.java
 * The full version of One Row Nim. This version can be CLUIPlayable 
 */

import java.awt.*;

class NimPlayerBad implements IPlayer {
  private OneRowNim game;

  public NimPlayerBad(OneRowNim game) {
    this.game = game;
  }

  public String makeAMove(String prompt) {
    return "" + randomMove();
  }

  private int randomMove() {
    int sticksLeft = game.getSticks();
    return 1 + (int) (Math.random() * Math.min(sticksLeft, game.MAX_PICKUP));
  }

  public String toString() {
    String className = this.getClass().toString(); // returns 'class NimPlayerBad'
    return className.substring(5); // cut off the word 'class'
  }
} // NimPlayerBad

public class OneRowNim extends TwoPlayerGame implements CLUIPlayableGame {
  public static final int MAX_PICKUP = 3;
  public static final int MAX_STICKS = 11;

  private int nSticks = MAX_STICKS;

  public OneRowNim() {
  } // Constructors

  public OneRowNim(int sticks) {
    nSticks = sticks;
  }

  public OneRowNim(int sticks, int starter) {
    nSticks = sticks;
    setPlayer(starter);
  }

  public boolean takeSticks(int num) {
    if (num &lt; 1 || num > MAX_PICKUP || num > nSticks)
      return false; // Error
    else // Valid move
    {
      nSticks = nSticks - num;
      return true;
    } // else
  }// takeSticks

  public int getSticks() {
    return nSticks;
  } // getSticks

  public String getRules() {
    return "\n*** The Rules of One Row Nim ***\n" +
        "(1) A number of sticks between 7 and " + MAX_STICKS + " is chosen.\n" +
        "(2) Two players alternate making moves.\n" +
        "(3) A move consists of subtracting between 1 and\n\t" +
        MAX_PICKUP + " sticks from the current number of sticks.\n" +
        "(4) A player who cannot leave a positive\n\t" +
        " number of sticks for the other player loses.\n";
  }

  public boolean gameOver() { /** From TwoPlayerGame */
    return (nSticks &lt;= 0);
  } // gameOver()

  public String getWinner() { /** From TwoPlayerGame */
    if (gameOver()) // {
      return "" + getPlayer() + " Nice game.";
    return "The game is not over yet."; // Game is not over
  } // getWinner()

  public String getGamePrompt() {
    return "\nYou can pick up between 1 and " + Math.min(MAX_PICKUP, nSticks) + " : ";
  }

  public String reportGameState() {
    if (!gameOver())
      return ("\nSticks left: " + getSticks() + " Who's turn: Player " + getPlayer());
    else
      return ("\nSticks left: " + getSticks() + " Game over! Winner is Player " + getWinner() + "\n");
  } // reportGameState()

  /** From CLUIPlayableGame interface */
  public void play(UserInterface ui) {
    int sticks = 0;
    ui.report(getRules());
    if (computer1 != null)
      ui.report("\nPlayer 1 is a " + computer1.toString());
    if (computer2 != null)
      ui.report("\nPlayer 2 is a " + computer2.toString());

    while (!gameOver()) {
      IPlayer computer = null; // Assume no computers playing
      ui.report(reportGameState());
      switch (getPlayer()) {
        case PLAYER_ONE: // Player 1's turn
          computer = computer1;
          break;
        case PLAYER_TWO: // Player 2's turn
          computer = computer2;
          break;
      } // cases

      if (computer != null) { // If computer's turn
        sticks = Integer.parseInt(computer.makeAMove(""));
        ui.report(computer.toString() + " takes " + sticks + " sticks.\n");
      } else { // otherwise, user's turn
        ui.prompt(getGamePrompt());
        sticks = Integer.parseInt(ui.getUserInput()); // Get user's move
      }
      if (takeSticks(sticks)) // If a legal move
        changePlayer();
    } // while
    ui.report(reportGameState()); // The game is now over
  }

  public String submitUserMove(String theMove) {
    int sticks = Integer.parseInt(theMove);
    if (takeSticks(sticks)) {
      changePlayer();
      if (gameOver()) {
        return reportGameState() + "\nGame won by player" + getWinner() + "\n";
      } else {
        return reportGameState() + getGamePrompt();
      }
    }
    return "\nOops. " + sticks + " is an illegal move." + getGamePrompt();
  }

  public void draw(Graphics g) {
    g.setColor(Color.red);
    for (int k = 1; k &lt;= nSticks; k++) {
      g.drawLine(10 + k * 10, 10, 10 + k * 10, 60);
    }
  }

  /**
   * A OneRowNim Keyboard Application Program
   */
  public static void main(String args[]) {
    KeyboardReader kb = new KeyboardReader();
    CLUIPlayableGame game = new OneRowNim();

    kb.prompt("How many computers are playing, 0, 1, or 2? ");
    int m = kb.getKeyboardInteger();
    for (int k = 0; k &lt; m; k++) {
      IPlayer computer = new NimPlayerBad((OneRowNim) game);
      ((TwoPlayerGame) game).addComputerPlayer(computer);
    }
    game.play(kb);
  } // main()
} // OneRowNim class

interface IPlayer {
  /**
   * makeAMove() defines how a move is made. It is meant
   * to be implemented by any object that plays the game.
   * 
   * @param prompt is a String that prompts the player for a move.
   * @return a String that describes the player's move
   */
  public String makeAMove(String prompt);
}

interface IGame {
  public String getGamePrompt();

  public String reportGameState();
} // IGame

interface UserInterface {
  public String getUserInput();

  public void report(String s);

  public void prompt(String s);
}

interface CLUIPlayableGame extends IGame {

  /**
   * play() implements the play loop for a game that
   * interfaces to a UserInterface. It is meant to
   * be implented by games that support a command-line
   * interface.
   */
  public abstract void play(UserInterface ui);
}

abstract class TwoPlayerGame {
  public static final int PLAYER_ONE = 1; // Class constants
  public static final int PLAYER_TWO = 2;

  protected boolean onePlaysNext = true; // Player 1 plays next
  protected int nComputers = 0; // How many computer players
  protected IPlayer computer1, computer2; // Computers are IPlayers

  /**
   * setPlayer() sets which player makes the first move.
   * 
   * @param starter, an int representing PLAYER_ONE or PLAYER_TWOI
   */
  public void setPlayer(int starter) {
    if (starter == PLAYER_TWO)
      onePlaysNext = false;
    else
      onePlaysNext = true;
  } // setPlayer()

  /**
   * getPlayer() returns an int representing whose turn it it.
   * 
   * @return an int representing PLAYER_ONE or PLAYER_TWO.
   */
  public int getPlayer() {
    if (onePlaysNext)
      return PLAYER_ONE;
    else
      return PLAYER_TWO;
  } // getPlayer()

  /**
   * changePlayer() toggles between PLAYER_ONE or PLAYER_TWO.
   */
  public void changePlayer() {
    onePlaysNext = !onePlaysNext;
  } // changePlayer

  /**
   * getNComputers() returns the number of computers playing
   * 
   * @return an int representing the number of computer players
   */
  public int getNComputers() {
    return nComputers;
  }

  /**
   * getRules() returns a String describing the rules of the game.
   * 
   * @return a String giving the game's rules.
   */
  public String getRules() {
    return "The rules of this game are: ";
  }

  /**
   * addComputerPlayer() adds to the number of computer players.
   * 
   * @param player is an IPlayer
   */
  public void addComputerPlayer(IPlayer player) {
    if (nComputers == 0)
      computer2 = player;
    else if (nComputers == 1)
      computer1 = player;
    else
      return; // No more than 2 players
    ++nComputers;
  }

  /**
   * gameOver() defines when the game is over. It is meant to be
   * implemented in subclasses.
   */
  public abstract boolean gameOver(); // Abstract Methods

  /**
   * getWinner() defines who wins the game. It is meant to be
   * implemented in subclasses.
   */
  public abstract String getWinner();
} // TwoPlayerGame

class KeyboardReader implements UserInterface {
  private BufferedReader reader;

  /**
   * KeyboardReader() constructor creates a BufferedReader that
   * is used for command-line and console I/O.
   */
  public KeyboardReader() {
    reader = new BufferedReader(new InputStreamReader(System.in));
  }

  /**
   * getKeyboardInput() returns input read from the keyboard.
   */
  public String getKeyboardInput() {
    return readKeyboard();
  }

  /**
   * getKeyboardInput() returns an integer read from the keyboard.
   */
  public int getKeyboardInteger() {
    return Integer.parseInt(readKeyboard());
  }

  /**
   * getKeyboardInput() returns a double value read from the keyboard.
   */
  public double getKeyboardDouble() {
    return Double.parseDouble(readKeyboard());
  }

  /**
   * getUserInput() is a method of the UserInterface class. It
   * returns input read from the keyboard.
   */
  public String getUserInput() {
    return getKeyboardInput();
  }

  /**
   * prompt() is a method of the UserInterface class. It
   * prints its parameter.
   * 
   * @param s is the String prompt
   */
  public void prompt(String s) {
    System.out.print(s);
  }

  /**
   * prompt() is a method of the UserInterface class. It
   * prints its parameter.
   * 
   * @param s is a String representing the state of the game.
   */
  public void report(String s) {
    System.out.print(s);
  }

  /**
   * display() prints its parameter.
   */
  public void display(String s) {
    System.out.print(s);
  }

  /**
   * readKeyboard() reads a line of input from the keyboard
   * where reader is a BufferedReader.
   * 
   * @return a String storing a line read from the keyboard.
   */
  private String readKeyboard() {
    String line = "";
    try {
      line = reader.readLine();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return line;
  }
} 
</input></program>
 <interactive iframe="iframe/repl-iframe-onerownim.html" width="95%" aspect="1:1"/>
</statement>
<solution>
      <p>
        The winning strategy would be to leave   the opponent with 1 or 5 or 9 or  13 ... sticks.
          A <c>NimPlayer</c> class that plays the optimal <c>OneRowNim</c> game 
          would be identical to the <c>NimPlayerBad</c> class except the <c>move():int</c> 
          method would be replaced with the following implementation:
       </p>
 <program language="java"><input>
public int move() {
    int sticksLeft = game.getSticks();
    if (sticksLeft % (game.MAX_PICKUP + 1) != 1)
        return (sticksLeft - 1) % (game.MAX_PICKUP +1);
    else {
        int maxPickup = Math.min(game.MAX_PICKUP, sticksLeft);
         return 1 + (int)(Math.random() * maxPickup);
    }
 }
 </input></program>
 <p>You might also want to modify <c>main()</c> to give the 
  user the choice of which player to use as the computer:
 </p>
  <program language="java"><input>
  public static void main(String args[]) {
    KeyboardReader kb = new KeyboardReader();
    OneRowNim game = new OneRowNim();
    kb.prompt("How many computers are playing, 0, 1, or 2? ");
    int m = kb.getKeyboardInteger();
    for (int k = 0; k &lt; m; k++) {
      kb.prompt("What type of player, " +
                  "NimPlayerBad = 1, or NimPlayer = 2 ? ");
      int choice = kb.getKeyboardInteger();
      if (choice == 1) {
        IPlayer computer = new NimPlayerBad(game);
        game.addComputerPlayer(computer);
      } else {
        IPlayer computer = new NimPlayer(game);
        game.addComputerPlayer(computer);
      }
    }
    game.play(kb);
 } // main()
 </input></program>
  </solution>
  </exercise>       
 </exercises>
</subsection>

  <subsection>
    <title>Extending the <c>TwoPlayerGame</c> Hierarchy</title>
    <p>
      Now that we've developed the <c>TwoPlayerGame</c> hierarchy,
      let's add a new game to it.
      If we've gotten the design right,
      adding a new game should be much simpler than developing it from scratch.
    </p>
    <p>
      The new game is a guessing game in which the two players take turns guessing a secret word.
      The secret word will be generated randomly from a collection of words maintained by the game object.
      The letters of the word will be hidden with question marks, as in
      <q>????????.</q>
      On each turn a player guesses a letter.
      If the letter is in the secret word,
      it replaces one or more question marks, as in
      <q>??????E?.</q>
      A player continues to guess until an incorrect guess is made and then it becomes the other player's turn.
    </p>
    <p>
      Of course, we want to develop a version of this game that can be played either by two humans,
      or by one human against a computer <mdash/> that is,
      against an <c>IPlayer</c> <mdash/> or by two different <c>IPlayer</c>s.
    </p>
    <figure xml:id="fig-wordguessuml">
      <caption>Design of the <c>WordGuess</c>
      class as part of <c>TwoPlayerGame</c> hierarchy.</caption>
      <image width="75%" source="chptr08/wordguess.png"/>
    </figure>
    <p>
      Let's call the game class <c>WordGuess</c> (<xref ref="fig-wordguessuml">Figure</xref>).
      The <c>WordGuess</c> class extends the
      <c>TwoPlayerGame</c> class and implements the <c>CLUIPlayableGame</c> interface.
      We don't show the details of the interfaces and the <c>TwoPlayerGame</c> class,
      as these have not changed.
      Also, following the design of <c>NimPlayerBad</c>, the <c>WordGuesser</c> class implements the <c>IPlayer</c> interface.
      Note how we show the association between
      <c>WordGuess</c> and zero or more <c>IPlayer</c>s.
      A <c>WordGuess</c> uses between zero and two instances of <c>IPlayer</c>s, which in this 
      game are implemented as <c>WordGuesser</c>s.
    </p>
    <listing xml:id="list-wordguess">
      <caption>The <c>WordGuess</c> class</caption>
 <program language="java"><input>
public class WordGuess extends TwoPlayerGame implements CLUIPlayableGame {
    private String secretWord;
    private StringBuffer currentWord;
    private StringBuffer previousGuesses;
    private int unguessedLetters;

    public WordGuess() {
        secretWord = getSecretWord();
        currentWord = new StringBuffer(secretWord);
        previousGuesses = new StringBuffer();
        for (int k = 0; k &lt; secretWord.length(); k++)
           currentWord.setCharAt(k,'?');
        unguessedLetters = secretWord.length();
    } // WordGuess()
    
    public String getPreviousGuesses() {
        return previousGuesses.toString();
    } // getPreviousGuesses()
    
    public String getCurrentWord() {
        return currentWord.toString();
    } // getCurrentWord()
    
    private String getSecretWord() {
        int num = (int)(Math.random()*10);
        switch (num)
        {   case 0: return "SOFTWARE";
            case 1: return "SOLUTION";
            case 2: return "CONSTANT";
            case 3: return "COMPILER";
            case 4: return "ABSTRACT";
            case 5: return "ABNORMAL";
            case 6: return "ARGUMENT";
            case 7: return "QUESTION";
            case 8: return "UTILIZES";
            case 9: return "VARIABLE";
            default: return "MISTAKES";
        } //switch
    } // getSecretWord()
    
    private boolean guessLetter(char letter) {
       previousGuesses.append(letter);
       if (secretWord.indexOf(letter) == -1)
            return false; // letter is not in secretWord
        else                                     // find letters in secretWord
        {   for (int k = 0; k &lt; secretWord.length(); k++)
            {   if (secretWord.charAt(k) == letter)
                {   if (currentWord.charAt(k) == letter)
                        return false;                   // already guessed
                    currentWord.setCharAt(k,letter);
                    unguessedLetters--;                 //one less to find
                } //if
            } //for
            return true;
        } //else
    } //guessLetter()

    public String getRules() {      // Overridden from TwoPlayerGame
        return "\n*** The Rules of Word Guess ***\n" +
        "(1) The game generates a secret word.\n" +
        "(2) Two players alternate taking moves.\n" +
        "(3) A move consists of guessing a letter in the word.\n" +
        "(4) A player continues guessing until a letter is wrong.\n" +
        "(5) The game is over when all letters of the word are guessed\n" +
        "(6) The player guessing the last letter of the word wins.\n";
    } //getRules()
    
    public boolean gameOver() {   // From TwoPlayerGame
        return (unguessedLetters &lt;= 0);
    } // gameOver()
    
    public String getWinner() {  // From TwoPlayerGame
        if (gameOver())
            return "Player " + getPlayer();
        else 
            return "The game is not over.";
    } // getWinner()
    
    public String reportGameState() {
        if (!gameOver())
            return "\nCurrent word " + currentWord.toString() + " Previous guesses "
                + previousGuesses + "\nPlayer " + getPlayer() + " guesses next.";
        else
            return "\nThe game is now over! The secret word is " + secretWord
              + "\n" + getWinner() + " has won!\n";
    } // reportGameState()
    
    public String getGamePrompt() {    // From CLUIPlayableGame
        return "\nGuess a letter that you think is in the secret word: ";
    } // getGamePrompt()
    
    public String move(String s) {
        char letter = s.toUpperCase().charAt(0);
        if (guessLetter(letter)) {   //if correct
            return "Yes, the letter " + letter +
                   " IS in the secret word\n";
         } else {
             changePlayer();
             return "Sorry, " + letter + " is NOT a " +
                    "new letter in the secret word\n";
         }
    } // move()
    
    public void play(UserInterface ui) {  // From CLUIPlayableGame
        ui.report(getRules());
        if (computer1 != null)
            ui.report("\nPlayer 1 is a " + computer1.toString());
        if (computer2 != null)
            ui.report("\nPlayer 2 is a " + computer2.toString());
        while(!gameOver()) {
           IPlayer computer = null;       // Assume no computers playing
           ui.report(reportGameState());
           switch(getPlayer()) {
           case PLAYER_ONE:             // Player 1's turn
               computer = computer1;
               break;
           case PLAYER_TWO:             // Player 2's turn
               computer = computer2;
               break;
           } // cases
           if (computer != null) {      // If computer's turn
               ui.report(move(computer.makeAMove("")));
           } else {                     // otherwise, user's turn
               ui.prompt(getGamePrompt());
               ui.report(move(ui.getUserInput()));
           }
        } // while
        ui.report(reportGameState());  // The game is now over
    } //play()} //WordGuess class
 </input></program>
</listing>
    <p>
      Let's turn now to the details of the <c>WordGuess</c> class,
      whose source code is shown in <xref ref="list-wordguess">Listing</xref>.
      The game needs to have a supply of words from which it can choose a secret word to present to the players.
      The <c>getSecretWord()</c> method will take care of this task.
      It calculates a random number and then uses that number,
      together with a <c>switch</c> statement,
      to select from among several words that are coded right into the <c>switch</c> statement.
    </p>
    <p>
      The secret word is stored in the <c>secretWord</c> variable.
      The <c>currentWord</c> variable stores the partially guessed word.
      Initially, <c>currentWord</c> consists entirely of question marks.
    </p>
    <p>
      As the players make correct guesses, <c>currentWord</c> is updated to show the 
      locations of the guessed letters.
      Because <c>currentWord</c> will change as the game progresses,
      it is stored in a <c>StringBuffer</c>, rather than in a <c>String</c>. 
      Recall that <c>String</c> s are immutable in Java,
      whereas a <c>StringBuffer</c> contains methods to insert letters and remove letters.
    </p>
    <p>
      The <c>unguessedLetters</c> variable stores the number of letters remaining to be guessed.
      When <c>unguessedLetters</c> equals 0, the game is over.
      This condition defines the <c>gameOver()</c> method,
      which is inherited from <c>TwoPlayerGame</c>. The winner of the game is the player 
      who guessed the last letter in the secret word.
      This condition defines the <c>getWinner()</c> method,
      which is also inherited from <c>TwoPlayerGame</c>. The other methods that are 
      inherited from <c>TwoPlayerGame</c> or implemented from the <c>CLUIPlayableGame</c> 
      are also implemented in a straightforward manner.
    </p>
    <p>
      A move in the <c>WordGuess</c> game consists of trying to guess a letter that occurs in the secret word.
      The <c>move()</c> method passes the guessed letter to the <c>guessLetter()</c> method,
      which checks whether the letter is a new, secret letter.
    </p>
    <p>  
      If so, <c>guessLetter()</c> takes care of the various housekeeping tasks.
      It adds the letter to <c>previousGuesses</c>, which keeps track of all the players' guesses.
      It decrements the number of <c>unguessedLetters</c>, which will become 0 when 
      all the letters have been guessed.
      And it updates <c>currentWord</c> to show where all occurrences of the secret letter are located.
      Note how <c>guessLetter()</c> uses a for-loop to cycle through the letters in the secret word.
      As it does so,
      it replaces the question marks in <c>currentWord</c> with the correctly guessed secret letter.
    </p>
    <p>  
      The <c>guessLetter()</c> method returns false if the guess is incorrect.
      In that case,
      the <c>move()</c> method changes the player's turn.
      When correct guesses are made,
      the current player keeps the turn.
    </p>
    <p>
      The <c>WordGuess</c> game is a good example of a string-processing  problem.
      It makes use of several of the <c>String</c> and <c>StringBuffer</c> methods that 
      we learned in Chapter<nbsp/>7.
      The implementation of <c>WordGuess</c>, as an extension of <c>TwoPlayerGame</c>, 
      is quite straight forward.
      One advantage of the <c>TwoPlayerGame</c> class hierarchy is that it decides 
      many of the important design issues in advance.
      Developing a new game is largely a matter of implementing methods whose 
      definitions have already been determined in the superclass or in the interfaces.
      This greatly simplifies the development process.
    </p>
    <p>
      Let's now discuss the details of <c>WordGuesser</c> class (Fig.
      <xref ref="list-wordguesser">Listing</xref>).
      Note that the constructor takes a <c>WordGuess</c> parameter.
      This allows <c>WordGuesser</c> to be passed a reference to the game,
      which accesses the game's <c>public</c> methods,
      such as <c>getPreviousGuesses()</c>. The <c>toString()</c> method is identical 
      to the <c>toString()</c> method in the <c>NimPlayerBad</c> example.
    </p>
    <p>
      The <c>makeAMove()</c> method,
      which is part of the <c>IPlayer</c> interface,
      is responsible for specifying the algorithm that the player uses to make a move.
      The strategy in this case is to repeatedly pick a random letter from
      <em>A</em> to <em>Z</em>
      until a letter is found that is not contained in <c>previousGuesses</c>. That way,
      the player will not guess letters that have already been guessed.
    </p>
    <listing xml:id="list-wordguesser">
      <caption>The <c>WordGuesser</c> class.</caption>
 <program language="java"><input>
public class WordGuesser implements IPlayer {
  private WordGuess game;
  
  public WordGuesser (WordGuess game) {
    this.game = game;
  }

  public String makeAMove(String prompt)  {
    String usedLetters = game.getPreviousGuesses();
    char letter;
    do {  // Pick one of 26 letters
      letter = (char)('A' + (int)(Math.random() * 26));
    } while (usedLetters.indexOf(letter) != -1);
    return "" + letter;
  }
  
  public String toString() { // returns 'NimPlayerBad'
    String className = this.getClass().toString();
    return className.substring(5);
  }
 } // WordGuesser
 </input></program>
</listing>

<activity label="wordguesser-ex">
  <statement>
  <p>The only new classes we needed to create a new two-player game were
    the <c>WordGuess</c> (<xref ref="list-wordguess">Listing</xref>) and 
    <c>WordGuesser</c> (<xref ref="list-wordguesser">Listing</xref>) classes.
    The gamr inherited the rest of its functionality from the <c>TwoPlayerGame</c>
    hierarchy.
  </p>
  <p>Use the replit below to experiment with the game. You can inspect the 
  source code in the replit.
</p>
<interactive iframe="iframe/repl-iframe-wordguess.html" width="95%" aspect="1:1"/>
  </statement>
</activity>
  </subsection>
</section>