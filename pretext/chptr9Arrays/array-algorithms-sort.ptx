<section xml:id="sec-sort">
  <title>Array Algorithms: Sorting</title>
  <introduction>
    <p>
      <term>Sorting</term> an array is the process of arranging its elements in ascending 
      or descending order.
      Sorting algorithms are among the most widely used algorithms.
      Any time large amounts of data are maintained,
      there is some need to arrange them in a particular order.
      For example,
      the telephone company needs to arrange its accounts by the last 
      name of the account holder as well as by phone number.
    </p>
  </introduction>
  <subsection>
    <title>Insertion Sort</title>
    <p>
      The first sorting algorithm we'll look at is known as
      <term>insertion sort</term>,
      so named because as it traverses through the array from the first to the last element,
      it inserts each element into its correct position in the partially sorted array.
    </p>
    <p>
      For an array of <em>N</em> elements,
      let's think of the array as divided into two parts.
      The <em>sorted</em> part will be the left hand side of the array.
      And the <em>unsorted</em> part will be the right hand side of the array.
      Initially, the sorted part consists of the first element in the 
      array <mdash/> i.e., the element at index 0.
    </p>
    <p>
      Insertion sort moves through the unsorted portion of the array <mdash/> that is its loop variable,
      <em>k</em>,
      ranges from 1 through <em>N-1</em>.
      On each iteration it inserts the
      <em>k</em>th element into its correct position in the sorted part of the array.
      To insert an element into the sorted part of the array,
      it may be necessary to move elements greater than the one being inserted out of the way.
    </p>
    <p>
      In pseudocode, insertion sort can be represented as follows:
    </p>
    <algorithm>
    <title>Insertion sort </title>
 <program language="java"><input>
Insertion Sort of an array, arr, of N elements into ascending order
1. For k assigned 1 through N-1
2.   Remove the element arr[k] and store it in x.
3.   For i starting at k-1 and for all preceding elements greater than x
4.     Move arr[i] one position to the right in the array.
5.   Insert x at its correct location.
 </input></program>
 </algorithm>
    <p>
      As is apparent from the pseudocode,
      we have nested for loops.
      The outer (<em>k</em>) loop, iterates through the array from 1 to <em>N-1</em>.
      The inner loop iterates as many times as necessary,
      starting with the element just to the left of the
      <em>k</em>th element in order to insert the
      <em>k</em>th element into its correct position in the sorted portion.
      Note that the <em>k</em>th element is always removed from the array
      (and stored in the variable <em>x</em>),
      to make room for elements that have to be moved to the right.
    </p>
    <p>
      To see how this works,
      consider an integer array containing the ages of five friends:
    </p>
 <program language="java"><input>
21 |  20  27  24  19      x = 20
      k
 </input></program>
    <p>
      For this five-element array,
      insertion sort initially will assume that the element at index 0 is in the correct position.
      The vertical line marks the boundary between the sorted and unsorted portions of the array.
      The outer loop will look at each of the remaining elements,
      one at a time,
      inserting it into its proper position in the sorted portion of the array.
    </p>
    <p>
      To insert 20, the number at index 1, the inner loop will move 21 to the right by one position.
      To do this, the algorithm will remove 20 from its location and store it in x.
      It will then move 21 one space to the right.
      Finally, it will insert 20,
      which is stored in x, at index 0, where it belongs relative to the other elements in the sorted part of the array.
      At this point,
      the sorted portion of the array consists of the first two elements,
      which are in the correct order, relative to each other.
    </p>
 <program language="java"><input>
20  21 |  27  24  19     x = 27
          k
 </input></program>
    <p>
      For the next element, 27,
      none of elements in the sorted portion need to be moved,
      so the inner for loop will iterate zero times.
      This gives us:
    </p>
 <program language="java"><input>
20  21  27 |  24  19    x = 24
              k
 </input></program>
    <p>
      For the fourth element, 24,
      only the previous element, 27,
      needs to be moved to the right, giving:
    </p>
 <program language="java"><input>
20  21  24  27 | 19    x = 19
                 k
 </input></program>
    <p>
      At this point,
      the sorted part of the array consists of the first four elements,
      which are in the correct order relative to each other.
      Finally, for the last element, 19,
      all of the elements in the sorted part of the array need to be moved one space to the right.
      This will require four iterations of the inner loop.
      We show the state of the array after each iteration of the inner for loop:
    </p>
 <program language="java"><input>
k
20 21 24 27 | 19   Remove 19 and store it x = 19
20 21 24 27 | 27   Move 27 to the right
20 21 24 24 | 27   Move 24 to the right
20 21 21 24 | 27   Move 21 to the right
20 20 21 24 | 27   Move 20 to the right
19 20 21 24 27 |   Insert x=19 at index 0
 </input></program>
    <p>
      Clearly, the fact that so many elements may have to moved on each 
      iteration of the outer loop shows that insertion sort is not a very efficient algorithm.
    </p>
    <p>
      The <c>Sort</c> class
      (<xref ref="lst-insertion">Listing</xref>)
      provides an implementation of the <c>insertionSort()</c> method.
      There are several points worth noting about this code.
      First, because it takes an <c>int</c> array as a parameter,
      the <c>insertionSort()</c> method will sort any array of integers,
      regardless of the array's length.
    </p>
    <listing xml:id="lst-insertion">
      <caption>Source code for  the <c>insertionSort()</c> method.
      Note in <c>main()</c> how an integer array is passed to the method.</caption>
 <program language="java"><input>
public class Sort {
  public void insertionSort(int arr[]) {
    int temp;  // Temporary variable for insertion
    for (int k = 1; k &lt; arr.length; k++)  {
      temp = arr[k]; // Remove element from array
      int i;         // For larger preceding elements
      for (i = k-1; i >= 0 AmPaMp arr[i] > temp; i--)
        arr[i+1] = arr[i]; // Move it right by one
      arr[i+1] = temp;       // Insert the element
    }
  } // insertionSort()

  public void print(int arr[]) {
    for (int k = 0; k &lt; arr.length; k++)// For each integer
      System.out.print( arr[k] + " \t "); //  Print it
    System.out.println();
  } // print()

  public static void main(String args[]) {
    int intArr[] = { 21, 20, 27, 24, 19 };
    Sort sorter = new Sort();
    sorter.print(intArr);
    sorter.insertionSort(intArr); // Passing an array
    sorter.print(intArr);
  } // main()
} //Sort
 </input></program>
    </listing>
    <p>
      Second, note how empty brackets (<c>[]</c>) are used to  declare an array parameter.
      If the brackets were omitted,
      then <c>arr</c> would be indistinguishable from an ordinary <c>int</c> parameter.
      Using the brackets indicates that this method takes an array of integers as its parameter.
    </p>
    <principle>
      <title>DEBUGGING TIP: Array Parameter</title>
      <p>
        When declaring an array parameter,
        empty brackets must be used either after the array name or after the 
        type name to distinguish it from a non-array parameter.
      </p>
    </principle>
    <p>
      Third, note how an array of integers is passed to the <c>insertionSort()</c> 
      method in the <c>main()</c> method:
    </p>
 <program language="java"><input>
sorter.insertionSort(intArr); // Pass intArr to the method
 </input></program>
    <p>
      That is, when passing an array to a method,
      you use just the name of the array, without brackets.
      Both of the following statements would cause syntax errors:
    </p>
 <program language="java"><input>
sorter.insertionSort(intArr[]); // Err: Can't have brackets
sorter.insertionSort(intArr[5]);// Err: passing an integer
 </input></program>
    <p>
      In the first case,
      empty brackets are only used when you declare an array variable,
      not when you are passing the array to a method.
      In the second case, <c>intArr[5]</c> is an <c>int</c>, not an array,
      and cannot legally be passed to <c>insertionSort()</c>.
    </p>
    <principle>
      <title>DEBUGGING TIP: Passing an Array Argument</title>
      <p>
        It is a syntax error to use empty brackets when passing an array argument to a method,
        where the only the array's name should be used.
        Empty rackets are only used when declaring an array variable.
      </p>
    </principle>
    <p>
      Finally, within the <c>insertionSort()</c> method itself,
      note that we declare the index for the inner <c>for</c> loop 
      outside of the <c>for</c> statement.
      This is so it can be used outside the scope of the <c>for</c> 
      loop to insert <c>temp</c> at location <c>arr[i+1]</c>, its correct location.
      Note also that the index of its correct location is
      <c>i+1</c>, rather than just <c>i</c>. This is because the inner 
      loop might iterate past location 0, which would give <em>i</em>
      a value of -1 at that point.
    </p>
  </subsection>
  <subsection xml:id="sec-selectionsort">
    <title>Selection Sort</title>
    <p>
      There are a large variety of array sorting algorithms.
      Selection sort is different from,
      but comparable to, insertion sort in its overall performance.
    </p>
    <p>
      To illustrate the <term>selection sort</term> algorithm,
      suppose you want to sort a deck of 25 index cards, numbered from 1 to 25.
      Lay the 25 cards out on a table,
      one card next to the  other.
      Starting with the first card,
      look through the deck and find the smallest card,
      the number 1 card,
      and exchange it with the card in the first location.
      Then, go through the deck again starting at the second card,
      find the next smallest card, the number 2 card,
      and exchange it with the card in the second location.
      Repeat this process 24 times.
    </p>
    <p>
      Translating this strategy into pseudocode gives the following algorithm:
    </p>

     <algorithm>
    <title>Selection sort </title>
 <program language="java"><input>
Selection sort of a 25-card deck from small to large
1. For count assigned 1 to 24  // Outer loop
2.   smallestCard = count
3.   For currentCard assigned count+1 to 25 // Inner loop
4.     If deck[currentCard] &lt; deck[smallestCard]
5.        smallestCard = currentCard
6.   If smallestCard != count // You need to swap
7       Swap deck[count] and deck[smallestCard]
 </input></program>
 </algorithm>
    <p>
      For a deck of 25 cards, you need to repeat the outer loop 24 times.
      In other words,
      you must select the smallest card and insert it in its proper location 24 times.
      The inner loop takes care of finding the smallest remaining card.
    </p>
    <p>
      On each iteration of this outer loop,
      the algorithm assumes that the card specified by the outer loop 
      variable, <c>count</c>, is the smallest card
      (line 2).
      It usually won't be, of course,
      but we have to start somewhere.
    </p>
    <p>
      The inner loop then iterates through the remaining cards 
      (from <c>count+1</c> to 25) and compares each one with the card 
      that is currently the smallest
      (lines 4 and 5).
      Whenever it finds a card that is smaller than the smallest card,
      it designates it as the smallest card
      (line 5).
      At the end of the loop,
      the <c>smallestCard</c> variable will remember where the smallest card is in the deck.
    </p>
    <p>
      Finally, when the inner loop is finished,
      the algorithm swaps the smallest card with the card in the location designated by <c>count</c>.
    </p>
  </subsection>
  <subsection xml:id="self-study-exercisesC24">
    <title>Algorithm: Swapping Memory Elements</title>
    <p>
      An important feature of the selection sort algorithm is its need to swap two array elements,
      or cards, to continue our example.
      Swapping two memory elements,
      whether they are array elements or not,
      requires the use of a temporary variable.
      For example, to swap the <em>j</em>th and
      <em>k</em>th elements in an <c>int</c> array named <c>arr</c>, you 
      would use the following algorithm: 
    </p>
    <algorithm>
    <title>Swap Two Variables </title>
 <program language="java"><input>
int temp = arr[j]; // Store the jth element in temp
arr[j] = arr[k];   // Move the kth element into j
arr[k] = temp;     // Move the jth element into k
 </input></program>
 </algorithm>
    <p>
      The <c>temp</c> variable temporarily stores the
      <em>j</em>th element so its value is not lost when its location is 
      overwritten by the <em>k</em>th element.
      The need for this variable is a subtlety that beginning programmers frequently overlook.
      But consider what would happen if we used the following erroneous algorithm: 
    </p>
 <program language="java"><input>
arr[j] = arr[k]; // Erroneous swap code
arr[k] = arr[j];
 </input></program>
    <p>
      If <c>arr[j]</c> refers to 4 and <c>arr[k]</c> refers to 2 
      in the array 1 4 2 8 , then the erroneous algorithm would produce 1 2 2 8 , the wrong result.
    </p>
    <principle>
      <title>PROGRAMMING TIP: Swapping Variables</title>
      <p>
        When swapping two memory elements,
        a temporary variable must be used to store one of the 
        elements while its memory location is being overwritten.
      </p>
    </principle>
    <p>
      The following method implements the swap algorithm for two elements,
      <em>el1</em> and <em>el2</em> of an <c>int</c> array:
    </p>
 <program language="java"><input>
void swap(int arr[], int el1, int el2) {
    int temp = arr[el1]; // Assign first element to temp
    arr[el1] = arr[el2]; // Overwrite first with second
    arr[el2] = temp;     // Overwrite second with first
} // swap()
 </input></program>
</subsection>
<subsection>
  <title>Self-Study Exercises</title>
      <ol>
        <li>
          <p>
            Sort the array, 24 18 90 1 0 85 34 18,
            using the insertion sort algorithm.
            Show the order of the elements after each iteration of the outer loop.
          </p>
        </li>
        <li>
          <p>
            Sort the array, 24 18 90 1 0 85 34 18,
            using the selection sort algorithm.
            Show the order of the elements after each iteration of the outer loop.
          </p>
        </li>
        <li>
          <p>
            Write a Java code segment to swap two <c>Student</c> objects, 
            <c>student1</c> and <c>student2</c>.
          </p>
        </li>
        <li>
          <p>
            Write a Java implementation of the <c>selectionSort()</c> 
            method to sort an array of <c>int</c>.
          </p>
        </li>
      </ol>
 </subsection>
  <subsection xml:id="paasing-params">
    <title>Passing a Value and Passing a Reference</title>
    <p>
      Recall from Chapter<nbsp/>3 that when an <c>Object</c> is passed to a method,
      a copy of the reference to the <c>Object</c> is passed.
      Because an array is an object,
      a reference to the array is passed to <c>insertionSort()</c>, rather than the whole array itself.
      This is in contrast to how a value of a primitive type is passed.
      In that case, a copy of the actual value is passed.
    </p>
    <principle>
      <title>Primitive vs. Object Parameters</title>
      <p>
        When a value of a primitive data type <mdash/> <c>int, double, char, boolean</c> <mdash/> 
        is passed as an argument to a method,
        a copy of the value is passed;
        when a reference to an <c>Object</c> is passed,
        a copy of the reference is passed.
      </p>
    </principle>
    <p>
      One implication of this distinction is that for arguments of primitive type,
      the original argument cannot be changed from within the method 
      because the method has only a copy of its value.
      For example,
      the following method takes an <c>int</c> parameter <em>n</em>,
      which is incremented within the method:
    </p>
 <program language="java"><input>
public void add1(int n) {
  System.out.print("n = " + n);
  n = n + 1;
  System.out.println(",  n = " + n);
}
 </input></program>
    <p>
      But because <em>n</em> is a parameter of primitive type,
      incrementing it within the method has no effect on its associated argument.
      Thus, in the following segment,
      the value of <em>Num</em> <mdash/> <em>n</em>'s associated argument <mdash/> will 
      not be affected by what goes on inside the <c>add()</c> method.
      The output produced by the code segment is shown in the comments:
    </p>
 <program language="java"><input>
int Num = 5;
System.out.println("Num = " + Num); // Prints Num = 5
add1(Num);                    // Prints n = 5,  n = 6
System.out.println("Num = " + Num); // Prints Num = 5
 </input></program>
    <p>
      Note that while <em>n</em>'s value has changed inside the method,
      <em>Num</em>'s value remains unaffected.
    </p>
    <p>
      The case is much different when we pass a reference to an object.
      In that case,
      the object itself can be manipulated from within the method.
      The <c>insertionSort()</c> method is a good illustration.
      In the following code  segment,
      the array <c>anArr</c> is printed,
      then sorted, and then printed again:
    </p>
 <program language="java"><input>
Sort sorter = new Sorter();
 int anArr[] = { 5, 10, 16, -2, 4, 6, 1 };
 sorter.print(anArr);           // Prints 5 10 16 -2 4 6 1
 sorter.insertionSort(anArr);   // Sorts anArr
 sorter.print(anArr);           // Prints -2 1 4 5 6 10 16
 </input></program>
    <p>
      As you can see, the object itself
      (the array)
      has been changed from within the method.
      This shows that changes within <c>insertionSort</c> to the array 
      referenced by <c>arr</c> are actually being made to <c>anArr</c> itself.
      If fact, because <c>insertionSort()</c> is passed a copy of the 
      reference variable <c>anArr</c>, both <c>arr</c> 
      and <c>anArr</c> are references to the very same object <mdash/> that is,
      to the same array (<xref ref="fig-arrayparam">Figure</xref>).
    </p>
    <figure xml:id="fig-arrayparam">
      <caption>When an array is passed to a method, both
      the parameter and the corresponding argument refer to the same object.</caption>
      <image width="60%" source="chptr09/8f11.png"/>
    </figure>
    <p>
      The justification for passing a reference to an object rather than the  
      entire object itself is a matter of efficiency.
      A reference uses just 4 bytes of data,
      whereas an object may use thousands of bytes.
      It would just be too inefficient to copy hundreds of bytes 
      each time an object is passed to a method.
      Instead, the method is passed a reference to the object,
      thereby giving it access to the object without incurring the 
      expense of copying large amounts of data.
      Indeed, Java provides no way to pass a copy of an object to a method.
    </p>
    </subsection>
    <subsection><title>Self-Study Exercise</title>
      <ol>
        <li>
          <p>
            Give the values that will be stored in <c>myArr</c> 
            and <c>k</c> after you invoke <c>mystery(myArr, k)</c>, 
            where <c>myArr</c>, <c>k</c> and <c>mystery()</c> are declared as follows:
 <program language="java"><input>
int myArr[] = {1,2,3,4,5};    int k = 3;
void mystery(int a[], int m) {
    ++a[m];
    --m;}
 </input></program>
          </p>
        </li>
      </ol>
  </subsection>
</section>