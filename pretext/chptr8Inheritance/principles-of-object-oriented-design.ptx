<section xml:id="principles-of-object-oriented-design">
  <title>Principles Of Object-Oriented Design</title>
  <p>
    To conclude this chapter,
    it will be helpful to focus briefly on how the examples we've seen address the various object-oriented design (OOD) principles we set out at the beginning of the book.
    <ul>
      Divide-and-Conquer Principle. Notice how all of the problems tackled in this chapter have been solved by dividing them into several classes, with each of the classes divided into separate methods. The very idea of a class hierarchy is an application of this principle. Encapsulation Principle. The superclasses in our designs,
<c>Cipher</c> and <c>TwoPlayerGame</c>, encapsulate those features of the class hierarchy that are shared by all objects in the hierarchy. The subclasses, <c>CaesarCipher</c> and <c>OneRowNim</c>, encapsulate features that make them distinctive with the class hierarchy. Interface Principle. The several Java interfaces we've designed, <c>IPlayer</c>, <c>CLUIPlayableGame</c> and <c>UserInterface</c>, specify clearly how various types of related objects will interact with each other through the methods contained in the interfaces. Clean interfaces make for clear communication among objects. Information Hiding Principle. We have continued to make consistent use of the <c>private</c> and <c>public</c> qualifiers, and have now introduced the <c>protected</c> qualifier to extend this concept. The inheritance mechanism gives subclasses access to protected and public elements of their superclasses. Generality Principle. As you move down a well-designed class hierarchy, you go from the more general to the more specific features of the objects involved. The abstract <em>encode()</em> method specifies the general form that encoding will take while the various implementations of this method in the subclasses provide the specializations necessary to distinguish, say, Caesar encoding from Transpose encoding. Similarly, the abstract <c>makeAMove()</c> method in the <c>IPlayer</c> interface provides a general format for a move in a two-player game, while its various implementations provide the specializations that distinguish one game from another. Extensibility Principle. Overriding inherited methods and implementing abstract methods from either an abstract superclass or a Java interface provide several well-designed ways to extend the functionality in an existing class hierarchy. Extending a class is a form of specialization of the features inherited from the superclass. Abstraction Principle. Designing a class hierarchy is an exercise in abstraction, as the more general features of the objects involved are moved into the superclasses. Similarly, designing a Java interface or an abstract superclass method is a form of abstraction, whereby the signature of the method is distinguished from its various implementations.
    </ul>
  </p>
  <p>
    These, then,
    are some of the ways that the several examples we have considered and this chapter's discussion have contributed to a deepening of our understanding of object-oriented design.
  </p>
  <p>
    \secSMHleft{Chapter Summary} \secKTH{Technical Terms} \begin{KT} abstract method
  </p>
  <p>
    actual type (dynamic type)
  </p>
  <p>
    ciphertext
  </p>
  <p>
    class inheritance
  </p>
  <p>
    cryptography
  </p>
  <p>
    dynamic binding (late binding)
  </p>
  <p>
    interface
  </p>
  <p>
    overloaded method
  </p>
  <p>
    plaintext
  </p>
  <p>
    polymorphic method
  </p>
  <p>
    polymorphism
  </p>
  <p>
    static binding (early binding)
  </p>
  <p>
    static type (declared type)
  </p>
  <p>
    substitution cipher
  </p>
  <p>
    transposition cipher
  </p>
  <p>
    \end{KT}
  </p>
  <p>
    \secKTH{Summary of Important Points}
    <ul>
      <li>
        <p>
          Inheritance is an object-oriented mechanism whereby subclasses inherit the public and protected instance variables and methods from their superclasses.
        </p>
      </li>
      <li>
        <p>
          Dynamic binding
          (or late binding)
          is the mechanism by which a method call is bound to
          (associated with)
          the correct implementation of the method at run time.
          In Java, all method calls,
          except for <c>final</c> or <c>private</c> methods,
          are resolved using dynamic binding.
        </p>
      </li>
      <li>
        <p>
          Static binding
          (or early binding)
          is the association of a method call with its corresponding implementation at compile time.
        </p>
      </li>
      <li>
        <p>
          Polymorphism is an object-oriented language feature in which a method call can lead to different actions depending on the object on which it is invoked.
          A polymorphic method is a method signature that is given different implementation by different classes in a class hierarchy.
        </p>
      </li>
      <li>
        <p>
          A static type is a variable's declared type.
          A dynamic type, or actual type,
          is the type of object assigned to that variable at a given point in a running program.
        </p>
      </li>
      <li>
        <p>
          An <c>abstract</c> method is a method definition that lacks an implementation.
          An <c>abstract</c> class is one that contains one or more <c>abstract</c> methods.
          An <c>abstract</c> class can be subclassed but not instantiated.
        </p>
      </li>
      <li>
        <p>
          A Java interface is a class that contains only method signatures and (possibly) constant declarations,
          but no variables.
          An interface can be implemented by a class by providing implementations for all of its abstract methods.
        </p>
      </li>
    </ul>
  </p>
  <p>
    \secANSHleft
    <ul>
      <li>
        <p>
          Running the <c>TestPrint</c> program will produce the output shown here.
          It is clear that the inherited <c>toString()</c> method is used by <c>println()</c> when printing a <c>TestPrint</c> object.
 <program language="java"><input>
56.0
 TestPrint@be2d65
 </input></program>
        </p>
      </li>
      <li>
        <p>
          If you override the <c>toString()</c> method in <c>TestPrint</c>, you should get something like the output shown here,
          depending on how you code <c>toString()</c>. It is clear that the <c>toString()</c> method is used polymorphously by <c>println()</c>.
 <program language="java"><input>
56.0
 Hello from TestPrint
 </input></program>
        </p>
      </li>
      <li>
        <p>
          The output produced when constructing objects of type <em>A</em>
          and <c>B</c> in the order shown in the exercise would be as follows,
          with each letter occurring on a separate line:
 <program language="java"><input>
A B B
 </input></program>
        </p>
      </li>
      <li>
        <p>
          The new implementation of <c>B</c>'s <c>method()</c> will invoke <c>A</c>'s version of the method before printing <em>B</em>.
          This will print
          <q>A A B A B</q>.
 <program language="java"><input>
void method () {
     super.method();
     System.out.println("B");
 }
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Give the definitions of classes <c>A</c> and <c>B</c> in the exercise,
          the marked statements would be invalid:
 <program language="java"><input>
A a = new B();   // Valid a B is an A
a = new A();     // Ok
B b = new A();   // Invalid. An A is not necessarily a B
b = new B();     // OK
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Given the class definitions and code segment in this exercise,
          the output would be, <c>A A B A B C</c>, with each letter printing on a separate line.
        </p>
      </li>
      <li>
        <p>
          Definition of an <c>Pig</c> subclass of <c>Animal</c>:
 <program language="java"><input>
public class Pig extends Animal {
    public Pig() {
        kind = "pig";
    }
    public String speak() {
        return "oink";
    }}
 </input></program>
        </p>
      </li>
      <li>
        <p>
          If polymorphism was not used in our design,
          the <c>talk()</c> method would have to be modified to the following in order to accommodate a <c>Pig</c> subclass:
 <program language="java"><input>
public String talk(Animal a) {
  if (a instanceof Cow)
     return "I am a " + kind + " and I go " + a.moo();
   else if (a instanceof Cat)
     return "I am a " + kind + " and I go " + a.meow();
   else if (a instanceof Pig)
     return "I am a " + kind + " and I go " + a.oink();
   else
     return "I don't know what I am";}
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Code to swap two <c>boolean</c> variables:
 <program language="java"><input>
boolean temp = b1; // Save b1's value
 b1 = b2;           // Change b1 to b2
 b2 = temp;         // Change b2 to b1's original value
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Creating a <c>ToggleButton</c> that can be used to deal or collect cards:
 <program language="java"><input>
private ToggleButton dealer =
            new ToggleButton("deal","collect");
 add(dealer);
 dealer.addActionListener(this);
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Modify the <c>Caesar</c> class so that it will allow various-sized shifts to be used.
 <program language="java"><input>
private int shift;
public void setShift(int n) { shift = n;    }
public int getShift()       { return shift; }
// Modification to encode():
ch = (char)('a' + (ch -'a'+ shift) % 26); // Shift
// Modification to decode():
ch = (char)('a' + (ch -'a'+ (26-shift)) % 26); // Shift
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Modify <c>Transpose.encode()</c> so that it uses a rotation instead of a reversal.
          The operation here is very similar to the shift operation in the Caesar cipher.
          It uses modular arithmetic to rearrange the letters in the word.
          For example, suppose the word is
          <q>hello</q>. Its letters are indexed from 0 to 4.
          The following table shows how the expression <c>((k+2) % 5)</c> will rearrange the letters as <em>k</em>
          varies from 0 to 4:
 <program language="java"><input>
k  charAt(k)  (k+2) % 5   charAt((k+2) % 5)
    -------------------------------------------
    0  'h'          2          'l'
    1  'e'          3          'l'
    2  'l'          4          'o'
    3  'l'          0          'h'
    4  'o'          1          'e'
// Modification to encode():
public String encode(String word) {
    StringBuffer result = new StringBuffer();
    for (int k=0; k &lt; word.length(); k++)
        result.append(word.charAt((k+2) % word.length()));
    return result.toString();}
 </input></program>
        </p>
      </li>
      <li>
        <p>
          A <c>NimPlayer</c> class that plays the optimal <c>OneRowNim</c> game would be identical to the <c>NimPlayerBad</c> class except the <c>move():int</c> method would be replaced with the following implementation:
 <program language="java"><input>
public int move() {
    int sticksLeft = game.getSticks();
    if (sticksLeft % (game.MAX_PICKUP + 1) != 1)
        return (sticksLeft - 1) % (game.MAX_PICKUP +1);
    else {
        int maxPickup = Math.min(game.MAX_PICKUP, sticksLeft);
         return 1 + (int)(Math.random() * maxPickup);
    }
 }
 </input></program>
        </p>
      </li>
    </ul>
  </p>
  <p>
    \marginpar{<term>Note:</term> For programming exercises,
    <term>first</term> draw a UML class diagram describing all classes and their inheritance relationships and/or associations.}
  </p>
  <ol>
    <li>
      <p>
        Fill in the blanks in each of the following sentences:
      </p>
      <ol>
        <li>
          <p>
            A method that lacks a body is an <c>__________</c> method.
          </p>
        </li>
        <li>
          <p>
            An <c>__________</c> is like a class except that it contains only instance methods,
            no instance variables.
          </p>
        </li>
        <li>
          <p>
            Two ways for a class to inherit something in Java is to <c>__________</c> a class and <c>__________</c> an interface.
          </p>
        </li>
        <li>
          <p>
            Instance variables and instance methods that are declared <c>__________</c> or <c>__________</c> are inherited by the subclasses.
          </p>
        </li>
        <li>
          <p>
            An object can refer to itself by using the <c>__________</c> keyword.
          </p>
        </li>
        <li>
          <p>
            If a GUI class intends to handle <c>ActionEvent</c> s, it must implement the <c>__________</c> interface.
          </p>
        </li>
        <li>
          <p>
            A <c>__________</c> method is one that does different things depending upon the object that invokes it.
          </p>
        </li>
      </ol>
      concepts:
      <ol>
        Class and <em>interface</em>. Stub method and <em>abstract method</em>. Extending a class and <em>instantiating an object</em>. Defining a method and <em>implementing a method</em>.
        <li>
          <p>
            A <c>protected</c> method and a <c>public</c> method.
          </p>
        </li>
        <li>
          <p>
            A <c>protected</c> method and a <c>private</c> method.
          </p>
        </li>
      </ol>
    </li>
    <li>
      <p>
        Draw a hierarchy to represent the following situation.
        There are lots of languages in the world.
        English, French, Chinese, and Korean are examples of natural languages.
        Java, C, and C++ are examples of formal languages.
        French and Italian are considered romance languages,
        while Greek and Latin are considered classical languages.
      </p>
    </li>
    <li>
      <p>
        Look up the documentation for the <c>JButton</c> class on Sun's Web site:
 <program language="java"><input>
http://java.sun.com/j2se/1.5.0/docs/api/
 </input></program>List the names of all the methods that would be inherited by the <c>ToggleButton</c> subclass that we defined in this chapter.
      </p>
    </li>
    <li>
      <p>
        Design and write a <c>toString()</c> method for the <c>ToggleButton</c> class defined in this chapter.
        The <c>toString()</c> method should return the <c>ToggleButton</c>'s current label.
      </p>
    </li>
    <li>
      <p>
        Design a class hierarchy rooted in the class <c>Employee</c> that includes subclasses for <c>HourlyEmployee</c> and <c>SalaryEmployee</c>. The attributes shared in common by these classes include the name,
        and job title of the employee,
        plus the accessor and mutator methods needed by those attributes.
        The salaried employees need an attribute for weekly salary,
        and the corresponding methods for accessing and changing this variable.
        The hourly employees should have a pay rate and an hours worked variable.
        There should be an abstract method called <c>calculateWeeklyPay()</c>, defined abstractly in the superclass and implemented in the subclasses.
        The salaried worker's pay is just the weekly salary.
        Pay for an hourly employee is simply hours worked times pay rate.
      </p>
    </li>
    <li>
      <p>
        Design and write a subclass of <c>JTextField</c> called <c>IntegerField</c> that is used for inputting integers but behaves in all other respects like a <c>JTextField</c>. Give the subclass a public method called <c>getInteger()</c>.
      </p>
    </li>
    <li>
      <p>
        Implement a method that uses the following variation of the Caesar cipher.
        The method should take two parameters,
        a <c>String</c> and an <c>int</c><em>N</em>.
        The result should be a <c>String</c> in which the first letter is shifted by <em>N</em>,
        the second by <m>N+1</m>, the third by <m>N+2</m>, and so on.
        For example, given the string
        <q>Hello,</q>
        and an initial shift of 1, your method should return
        <q>Igopt.</q>
        Write a method that converts its <c>String</c> parameter so that letters are written in blocks five characters long.
      </p>
    </li>
    <li>
      <p>
        Design and implement an GUI that lets the user type a document into a <c>TextArea</c> and then provides the following analysis of the document:
        the number of words in the document,
        the number of characters in the document,<nbsp/>and the percentage of words that have more than six letters.
      </p>
    </li>
    <li>
      <p>
        Design and implement a <c>Cipher</c> subclass to implement the following substitution cipher: Each letter in the alphabet is replaced with a letter from the opposite end of the alphabet:
        <em>a</em> is replaced with <em>z</em>,
        <em>b</em> with <em>y</em>, and so forth.
      </p>
    </li>
    <li>
      <p>
        One way to design a substitution alphabet for a cipher is to use a keyword to construct the alphabet.
        For example, suppose the keyword is
        <q>zebra.</q>
        You place the keyword at the beginning of the alphabet,
        and then fill out the other 21 slots with remaining letters,
        giving the following alphabet:
 <program language="java"><input>
Cipher alphabet:   zebracdfghijklmnopqstuvwxy
Plain alphabet:    abcdefghijklmnopqrstuvwxyz
 </input></program>Design and implement an <c>Alphabet</c> class for constructing these kinds of substitution alphabets.
        It should have a single public method that takes a keyword <c>String</c> as an argument and returns an alphabet string.
        Note that an alphabet cannot contain duplicate letters,
        so repeated letters in a keyword like
        <q>xylophone</q>
        would have to be removed.
      </p>
    </li>
    <li>
      <p>
        Design and write a <c>Cipher</c> subclass for a substitution cipher that uses an alphabet from the <c>Alphabet</c> class created in the previous exercise.
        Challenge: Find a partner and concoct your own encryption scheme.
        Then work separately with one partner writing <c>encode()</c> and the other writing <c>decode()</c>. Test to see that a message can be encoded and then decoded to yield the original message.
      </p>
    </li>
    <li>
      <p>
        Design a <c>TwoPlayerGame</c> subclass called <c>MultiplicationGame</c>. The rules of this game are that the game generates a random multiplication problem using numbers between 1 and 10, and the players,
        taking turns, try to provide the answer to the problem.
        The game ends when a wrong answer is given.
        The winner is the player who did not give a wrong answer.
      </p>
    </li>
    <li>
      <p>
        Design a class called <c>MultiplicationPlayer</c> that plays the multiplication game described in the previous exercise.
        This class should implement the <c>IPlayer</c> interface.
      </p>
    </li>
    <li>
      <p>
        Design a <c>TwoPlayerGame</c> subclass called <c>RockPaperScissors</c>. The rules of this game are that each player,
        at the same time, picks either a rock, a paper, or a scissors.
        For each round, the rock beats the scissors,
        the scissors beats the paper,
        and the paper beats the rock.
        Ties are allowed.
        The game is won in a best out of three fashion when one of the players wins two rounds.
      </p>
    </li>
    <li>
      <p>
        Design a class called <c>RockPaperScissorsPlayer</c> that plays the the game described in the previous exercise.
        This class should implement the <c>IPlayer</c> interface.
      </p>
    </li>
  </ol>
</section>