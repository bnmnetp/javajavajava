<section xml:id="generic-client-server-classes">
  <title>CASE STUDY: Generic Client/Server Classes</title>
  <introduction>
    <p>
      Suppose your boss asks you to set up generic client/server classes  that can be used to implement a number of related client/server applications.
      One application that the company has in mind is a query service,
      in which the client would send a query string to the server,
      and the server would interpret the string and return a string that provides the answer.
      For example, the client might send the query,
      <q>Hours of service,</q>
      and the client would respond with the company's business hours.
    </p>
    <p>
      Another application the company wants will enable the client to fill out an order form and transmit it as a string to the server.
      The server will interpret the order,
      fill it, and return a receipt,
      including instructions as to when the customer will receive the order.
    </p>
    <p>
      All of the applications to be supported by this generic client/server will communicate via strings,
      so something very much like the
<c>readFromSocket()</c> and <c>writeToSocket()</c> methods can be used for their communication.
      Of course, you want to design classes so they can be easily extended to support byte-oriented,
      two-way communications, should that type of service become needed.
    </p>
    <p>
      In order to test the generic models,
      we will subclass them to create a  simple echo service.
      This service will echo back to the client any message that the server receives.
      For example,
      we'll have the client accept keyboard input from the user and then send the user's input to the server and simply report what the server returns.
      The following shows the output generated by a typical client session:
    </p>
 <program language="java"><input>
CLIENT: connected to 'java.cs.trincoll.edu'
SERVER: Hello, how may I help you?
CLIENT: type a line or 'goodbye' to quit
INPUT: hello
SERVER: You said 'hello'
INPUT: this is fun
SERVER: You said 'this is fun'
INPUT: java java java
SERVER: You said 'java java java'
INPUT: goodbye
SERVER: Goodbye
CLIENT: connection closed
 </input></program>
    <p>
      On the server side,
      the client's message will be read from the input stream and then simply echoed back
      (with some additional characters attached)
      through the output stream.
      The server doesn't display a trace of its activity other than to report when connections are established and closed.
      We will code the server in an infinite loop so that it will accept connections from a (potentially) endless stream of clients.
      In fact, most servers are coded in this way.
      They are designed to run forever and must be restarted whenever the host that they are running needs to be rebooted.
      The output from a typical server session is as follows:
    </p>
 <program language="java"><input>
Echo server at java.cs.trincoll.edu/157.252.16.21 waiting for connections
Accepted a connection from java.cs.trincoll.edu/157.252.16.21
Closed the connection
Accepted a connection from java.cs.trincoll.edu/157.252.16.21
Closed the connection
 </input></program>
    <principle>
      <title>EFFECTIVE DESIGN: Infinite Loop</title>
      <p>
        A server is an application that's designed to run in an infinite loop.
        The loop should be exited only when some kind of exception occurs.
      </p>
    </principle>
  </introduction>
  <subsection>
    <title>Object-Oriented Design</title>
    <p>
      A suitable solution for this project will make extensive use of object-oriented design principles.
      We want <c>Server</c> and
<c>Client</c> classes that can easily be subclassed to support a wide variety of services.
      The solution should make appropriate use of <em>inheritance</em>
      and <em>polymorphism</em> in its design.
      Perhaps the best way to develop our generic class is first to design the echo service,
      as a typical example, and then generalize it.
    </p>
  </subsection>
  <subsection>
    <title>The Threaded Root Subclass: <c>ClientServer</c></title>
    <p>
      One lesson we can draw at the outset is that both clients and servers 
      use basically the same socket I/O methods.

      Thus, as we've seen,
      the
<c>readFromSocket()</c> and <c>writeToSocket()</c> methods could be used by both clients 
and servers.
      Because we want all clients and servers to inherit these methods,
      they must be placed in a common superclass.
      Let's name this the <c>ClientServer</c> class.
    </p>
    <p>
      Where should we place this class in the Java hierarchy?
      Should it be a direct subclass of <c>Object</c>, or should it extend some other class that would give it appropriate functionality?
      One feature that would make our clients and servers more useful is if they were independent threads.
      That way they could be instantiated as part of another object and given the subtask of communicating on behalf of that object.
    </p>
    <p>
      Therefore, let's define the <c>ClientServer</c> class as a subclass of
<c>Thread</c>(<xref ref="fig-subclassThread"></xref>).
      Recall from Chapter<nbsp/>14 that the typical way to derive functionality from a <c>Thread</c> subclass is to override the <c>run()</c> method.
      The <c>run()</c> method will be a good place to implement the client and server protocols.
      Because they are different,
      we'll define <c>run()</c> in both the <c>Client</c> and <c>Server</c> subclasses.
    </p>
    <figure xml:id="fig-subclassThread">
      <caption>ClientServer as a subclass of Thread</caption>
      <image width="50%" source="chptr15/p851f1.png"/> 
    </figure>
    <p>
      For now, the only methods contained in <c>ClientServer</c>(<xref ref="list-clientserver">Listing</xref>) are the two I/O methods we designed.
      The only modification we have made to the methods occurs in the <c>writeToSocket()</c> method,
      where we have added code to make sure that any strings written to the socket are terminated with an end-of-line character.
    </p>
    <p>
      This is an important enhancement,
      because the read loop in the
<c>readFromSocket()</c> method expects to receive an end-of-line character.
      Rather than rely on specific clients to guarantee that their strings end with 
      <c>\n</c>, our design takes care of   this problem for them.
      This ensures that every communication that takes place between one of our clients and servers will be line oriented.

    </p>
    <listing xml:id="list-clientserver">
      <caption>The <c>ClientServer</c> class serves as the superclass for client/server applications.</caption>
 <program language="java"><input>
import java.io.*;
import java.net.*;
public class ClientServer extends Thread {
  protected InputStream iStream;  // Instance variables
  protected OutputStream oStream;
  protected String readFromSocket(Socket sock)
                                     throws IOException {
    iStream = sock.getInputStream();
    String str="";
    char c;
    while (  ( c = (char) iStream.read() ) != '\n')
      str = str + c + "";
    return str;
  }
  protected void writeToSocket(Socket sock, String str)
                                     throws IOException {
    oStream = sock.getOutputStream();
    if (str.charAt( str.length() - 1 ) != '\n')
      str = str + '\n';
    for (int k = 0; k &lt; str.length() ; k++)
      oStream.write(str.charAt(k));
  } // writeToSocket()
}// ClientServer
 </input></program>
</listing>
   
    <principle>
      <title>EFFECTIVE DESIGN: Defensive Design</title>
      <p>
        Code that performs I/O, whether across a network or otherwise,
        should be designed to anticipate and remedy common errors.
        This will lead to more robust programs.
      </p>
    </principle>
  </subsection>
  <subsection>
    <title>The <c>EchoServer</c> Class</title>
   
    <p>
      Let's now develop a design for the echo server.
      This class will be a subclass of <c>ClientServer</c>(<xref ref="fig-p852f1"></xref>)).
      <figure xml:id="fig-p852f1">
        <caption>Design of the <c>EchoServer</c> class.</caption>
        <image width="50%" source="chptr15/p852f1.png"/>
      </figure>
      As we saw in discussing the server protocol,
      one task that echo server will do is create a <c>ServerSocket</c> and establish a port number for its service.
      Then it will wait for a <c>Socket</c> connection,
      and once a connection is accepted,
      the echo server will then communicate with the client.
      This suggests that  our server needs at least two instance variables.
      It also suggests that the task of creating a <c>ServerSocket</c> would be an appropriate action for its constructor method.
      This leads to the following initial definition:
    </p>
 <program language="java"><input>
import java.net.*;
import java.io.*;
public class EchoServer extends ClientServer {
    private ServerSocket port;
    private Socket socket;
    public EchoServer(int portNum, int nBacklog)  {
      try {
        port = new ServerSocket (portNum, nBacklog);
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    public void run() { }  // Stub method
  }// EchoServer
 </input></program>
    <p>
      Note that the constructor method catches the <c>IOException</c>. 
      Note also that we have included a stub version of <c>run()</c>, which we want to define in this class.
    </p>
    <p>
      Once <c>EchoServer</c> has set up a port,
      it should issue the
<c>port.accept()</c> method and wait for a client to connect.
      This part of the server protocol belongs in the <c>run()</c> method.
      As we have said,
      most servers  are designed to run in an infinite loop.
      That is, they don't just handle one request and then quit.
      Instead, once started
      (usually by the system),
      they repeatedly handle requests until deliberately stopped by the system.
      This leads to the following run algorithm:
    </p>
 <program language="java"><input>
public void run() {
  try {
    System.out.println("Echo server at "
                   + InetAddress.getLocalHost()
                   + " waiting for connections ");
    while(true) {
      socket = port.accept();
      System.out.println("Accepted a connection from "
                           + socket.getInetAddress());
      provideService(socket);
      socket.close();
      System.out.println("Closed the connection\n");
    }
  } catch (IOException e) {
     e.printStackTrace();
  }
}// run()
 </input></program>
    <p>
      For simplicity,
      we are printing the server's status messages on <c>System.out</c>. Ordinarily these should go to a log file.
      Note also that the details of the actual service algorithm are hidden in the <c>provideService()</c> method.
    </p>
    <p>
      As described earlier,
      the <c>provideService()</c> method consists of writing a greeting to the client and then repeatedly reading a string from the input stream and echoing it back to the client via the output stream.
      This is easily done using the <c>writeToSocket()</c> and <c>readFromSocket()</c> methods we developed.
      The implementation of this method is shown,
      along with the complete implementation of <c>EchoServer</c>, in 
      <xref ref="list-echoserver">Listing</xref>.
    </p>
    <p>
      The protocol used by <c>EchoServer.provideService()</c> starts by saying
      <q>hello</q>
      and loops until the client says
      <q>goodbye.</q>
      When the client says
      <q>goodbye,</q>
      the server responds with
      <q>goodbye.</q>
      In all other cases it responds with
      <q>You said X,</q>
      where X is the string that was received from the client.
      Note the use of the
<c>toLowerCase()</c> method to convert client messages to lowercase.
      This simplifies the task of checking for
      <q>goodbye</q>
      by removing the necessity of checking for different spellings of
      <q>Goodbye.</q>
    </p>
    <principle>
      <title>EFFECTIVE DESIGN: Defensive Design</title>
      <p>
        Converting I/O to lowercase helps to minimize miscommunication between a client and server and leads to a more robust protocol.
      </p>
    </principle>
    <p>
      This completes the design of the <c>EchoServer</c>. We have deliberately designed it in a way that will make it easy to convert into a generic server.
      Hence, we have the motivation for using <c>provideService()</c> as the name of the method that provides the echo service.
      In order to turn
<c>EchoServer</c> into a generic <c>Server</c> class,
      we can simply make
<c>provideService()</c> an abstract method,
      leaving its implementation to  the <c>Server</c> subclasses.
      We'll discuss the details of this change later.
    </p>
    <listing xml:id="list-echoserver">
      <caption><c>EchoServer</c> simply echoes the client's message.</caption>
 <program language="java"><input>
import java.net.*;
import java.io.*;
public class EchoServer extends ClientServer {
  private ServerSocket port;
  private Socket socket;
  public EchoServer( int portNum, int nBacklog)  {
    try {
      port = new ServerSocket (portNum, nBacklog);
    } catch (IOException e) {
      e.printStackTrace();
    }
  } // EchoServer()
  public void run() {
    try {
      System.out.println("Echo server at " +
        InetAddress.getLocalHost() + " waiting for connections ");
      while(true) {
        socket = port.accept();
        System.out.println("Accepted a connection from " +
                                        socket.getInetAddress());
        provideService(socket);
        socket.close();
        System.out.println("Closed the connection\n");
      } // while
    } catch (IOException e) {
       e.printStackTrace();
    } // try/catch
  }// run()
  protected void provideService (Socket socket) {
    String str="";
    try {
      writeToSocket(socket, "Hello, how may I help you?\n");
      do {
        str = readFromSocket(socket);
        if (str.toLowerCase().equals("goodbye"))
          writeToSocket(socket, "Goodbye\n");
        else
          writeToSocket( socket, "You said '" + str + "'\n");
      }  while (!str.toLowerCase().equals("goodbye"));
    } catch (IOException e) {
      e.printStackTrace();
    } // try/catch
  }// provideServer()
  public static void main(String args[]) {
      EchoServer server = new EchoServer(10001,3);
      server.start();
  }// main()
}// EchoServer
 </input></program>
</listing>
  </subsection>
  
  <subsection>
    <title>The <c>EchoClient</c> Class</title>

 
    <p>
      The <c>EchoClient</c> class is just as easy to design (<xref ref="fig-p854f1">Fig</xref>).
      It, too, will be a subclass of <c>ClientServer</c>. It needs an instance variable for the <c>Socket</c> that it will use,
      and its constructor should be responsible for opening a socket connection to a particular server and port.
      The main part of its protocol should be placed in the <c>run()</c> method.
   
      <figure    xml:id="fig-p854f1"><caption>EchoClient Class</caption>
      <image width="50%" source="chptr15/p854f1.png"/>
      </figure>
      The initial definition is as follows:
    </p>
 <program language="java"><input>
import java.net.*;
import java.io.*;
public class EchoClient extends ClientServer {
     protected Socket socket;
     public EchoClient(String url, int port) {
       try {
         socket = new Socket(url, port);
         System.out.println("CLIENT: connected to "
                             + url + ":" + port);
       } catch (Exception e) {
         e.printStackTrace();
         System.exit(1);
       }
     }// EchoClient()
    public void run() { }// Stub method
  }// EchoClient
 </input></program>
    <p>
      The constructor method takes two parameters that specify the URL and port number of the echo server.
      By making these parameters, rather than hard coding them within the method,
      we give the client the flexibility to connect to servers on a variety of hosts.
    </p>
    <p>
      As with other clients, <c>EchoClient</c>'s <c>run()</c> method will consist of requesting some kind of service from the server.
      Our initial design called for <c>EchoClient</c> to repeatedly input a line  from the user,
      send the line to the server, and then display the server's response.
      Thus, for this particular client,
      the service requested consists of the following algorithm:
    </p>
 <program language="java"><input>
Wait for the server to say "hello".
Repeat
    Prompt and get and line of input from the user.
    Send the user's line to the server.
    Read the server's response.
    Display the response to the user.
until the user types "goodbye"
 </input></program>
    <p>
      With an eye toward eventually turning <c>EchoClient</c> into a generic client,
      let's encapsulate this procedure into a <c>requestService()</c> method that we can simply call from the <c>run()</c> method.
      Like for the <c>provideService()</c> method,
      this design is another example of the encapsulation principle:
    </p>
    <principle>
      <title>EFFECTIVE DESIGN: Encapsulation</title>
      <p>
        Encapsulating a portion of the algorithm into a separate method makes it easy to change the algorithm by overriding the method.
      </p>
    </principle>
    <p>
      The <c>requestService()</c> method will take a <c>Socket</c> parameter and perform all the I/O for this particular client:
    </p>
 <program language="java"><input>
protected void requestService(Socket socket) throws IOException {
  String servStr = readFromSocket(socket);                // Check for "Hello"
  System.out.println("SERVER: " + servStr);    // Report the server's response
  System.out.println("CLIENT: type a line or 'goodbye' to quit");    // Prompt
  if (servStr.substring(0,5).equals("Hello")) {
    String userStr = "";
    do {
      userStr = readFromKeyboard();                              // Get input
      writeToSocket(socket, userStr + "\n");             // Send it to server
      servStr = readFromSocket(socket);         // Read the server's response
      System.out.println("SERVER: " + servStr);   // Report server's response
    } while (!userStr.toLowerCase().equals("goodbye"));    // Until 'goodbye'
  }
} // requestService()
 </input></program>
    <p>
      Although this method involves several lines,
      they should all be familiar to you.
      Each time the client reads a message from the socket,
      it prints it on <c>System.out</c>. The first message it reads should start with the substring
      <q>Hello</q>. This is part of its protocol with the client.
      Note how the <c>substring()</c> method is used to test for this.
      After the initial greeting from the server,
      the client begins reading user input from the keyboard,
      writing it to the socket, then reading the server's response,
      and displaying it on
<c>System.out</c>.
    </p>
    <p>
      Note that the task of reading user input from the keyboard has been made into a separate method,
      which is one we've used before:
    </p>
 <program language="java"><input>
protected String readFromKeyboard() throws IOException {
  BufferedReader input = new BufferedReader(
                   new InputStreamReader(System.in));
  System.out.print("INPUT: ");
  String line = input.readLine();
  return line;
}// readFromKeyboard()
 </input></program>
    <p>
      The only method remaining to be defined is the <c>run()</c>, which is shown with the complete definition of <c>EchoClient</c> in 
      <xref ref="list-echoclient">Listing</xref>.
      The <c>run()</c> method can simply call the <c>requestService()</c> method.
      When control returns from the
<c>requestService()</c> method, <c>run()</c> closes the socket connection.
      Because <c>requestService()</c> might throw an <c>IOException</c>, the entire method must be embedded within a <c>try/catch</c> block that catches that exception.
    </p>
    <listing xml:id="list-echoclient">
      <caption>The <c>EchoClient</c> class prompts the user for a string
      and sends it to the <c>EchoServer</c>, which simply
      echoes it back.</caption>
      
 <program language="java"><input>
import java.net.*;
import java.io.*;
public class EchoClient extends ClientServer {
  protected Socket socket;
  public EchoClient(String url, int port) {
     try {
        socket = new Socket(url, port);
        System.out.println("CLIENT: connected to " + url + ":" + port);
      } catch (Exception e) {
        e.printStackTrace();
        System.exit(1);
      }
   }// EchoClient()
  public void run() {
    try {
        requestService(socket);
        socket.close();
        System.out.println("CLIENT: connection closed");
    } catch (IOException e) {
        System.out.println(e.getMessage());
        e.printStackTrace();
    }
  }// run()
  protected void requestService(Socket socket) throws IOException {
    String servStr = readFromSocket(socket);                 // Check for "Hello"
    System.out.println("SERVER: " + servStr);     // Report the server's response
    System.out.println("CLIENT: type a line or 'goodbye' to quit");// Prompt user
    if (servStr.substring(0,5).equals("Hello")) {
       String userStr = "";
       do {
         userStr = readFromKeyboard();                 // Get input from user
         writeToSocket(socket, userStr + "\n");   // Send it to server
         servStr = readFromSocket(socket);          // Read server's response
         System.out.println("SERVER: " + servStr);  // Report server's response
       } while (!userStr.toLowerCase().equals("goodbye"));// Until 'goodbye'
    }
  }// requestService()
  protected String readFromKeyboard( ) throws IOException {
    BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
    System.out.print("INPUT: ");
    String line = input.readLine();
    return line;
  }// readFromKeyboard()
  public static void main(String args[]) {
    EchoClient client = new EchoClient("java.trincoll.edu",10001);
    client.start();
  }// main()
}// EchoClient
 </input></program>
</listing>
  </subsection>
  <subsection>
    <title>Testing the Echo Service</title>
    <p>
      Both <c>EchoServer</c> and <c>EchoClient</c> contain <c>main()</c> methods (
        <xref ref="list-echoserver"></xref>
      and <xref ref="list-echoclient"></xref>).
      In order to test the programs,
      you would run the server on one computer and the client on another computer.
      (Actually they can both be run on the same computer,
      although they wouldn't know this and would still access each other through a socket connection.)
    </p>
    <p>
      The <c>EchoServer</c> must be started first,
      so that its service will be available when the client starts running.
      It also must pick a port number.
      In this case it picks 10001.
      The only constraint on its choice is that it cannot use one of the privileged port numbers<mdash/>those below 1024<mdash/>and it cannot use a port that's already in use.
    </p>
 <program language="java"><input>
public static void main(String args[]) {
    EchoServer server = new EchoServer(10001,3);
    server.start();
  }// main()
 </input></program>
    <p>
      When an <c>EchoClient</c> is created,
      it must be given the server's URL (<c>java.\-trincoll.edu</c>) and the port that the service is using:
    </p>
 <program language="java"><input>
public static void main(String args[]) {
    EchoClient client =
            new EchoClient("java.trincoll.edu",10001);
    client.start();
  }// main()
 </input></program>
    <p>
      As they are presently coded,
      you will have to modify both
<c>EchoServer</c> and <c>EchoClient</c> to provide the correct URL and port for your environment.
      In testing this program,
      you might wish to experiment by trying to introduce various errors into the code and observing the results.
      When you run the service,
      you should observe something like the following output on the client side:
    </p>
 <program language="java"><input>
CLIENT: connected to java.trincoll.edu:10001
SERVER: Hello, how may I help you?
CLIENT: type a line or 'goodbye' to quit
INPUT: this is a test
SERVER: You said 'this is a test'
INPUT: goodbye
SERVER: Goodbye
CLIENT: connection closed
 </input></program>
  </subsection>
</section>