<section xml:id="example-the-cipher-class-hierarchy">
  <title>Example: The Cipher Class Hierarchy</title>
  <introduction>
    <p>
      Suppose we wish to design a collection of cipher classes,
      including a Caesar cipher and a transposition cipher.
      Because the basic operations used in all forms of encryption are the same,
      both the <c>Caesar</c> class and the <c>Transpose</c> class will have methods to <c>encrypt()</c> and <c>decrypt()</c> messages,
      where each message is assumed to be a string of words separated by spaces.
      These methods will take a <c>String</c> of words and translate each word using the encoding method that is appropriate for that cipher.
      Therefore, in addition to
<c>encrypt()</c> and <c>decrypt()</c>, each cipher class will need polymorphic <c>encode()</c> and <c>decode()</c> methods,
      which take a single word and encode or decode it according to the rules of that particular cipher.
    </p>
    <p>
      From a design perspective the <c>encrypt()</c> and <c>decrypt()</c> methods will be the same for every class: They simply break the message into words and encode or decode each word.
      However, the
<c>encode()</c> and <c>decode()</c> methods will be different for each different cipher.
      The <c>Caesar.encode()</c> method should replace each letter of a word with its substitute,
      whereas the
<c>Transpose.encode()</c> method should rearrange the letters of the word.
      Given these considerations, how should we design this set of classes?
    </p>
    <p>
      Because all of the various ciphers will have the same methods,
      it will <image width="73%" source="chptr07/p380f1.png"/> be helpful to define a common <c>Cipher</c> superclass (Fig.
      <xref ref="fig-cipherhier"></xref>). <c>Cipher</c> will encapsulate those features that the individual cipher classes have in common<mdash/>the
<c>encrypt()</c>, <c>decrypt()</c>, <c>encode()</c>, and <c>decode()</c> methods.
    </p>
    <p>
      Some of these methods can be implemented in the <c>Cipher</c> class itself.
      For example,
      the <c>encrypt()</c> method should take a message in a <c>String</c> parameter,
      encode each word in the message,
      and return a <c>String</c> result.
      The following method definition will work for any cipher:
    </p>
    <p>
      
    </p>
 <program language="java"><input>
public String encrypt(String s) {
  StringBuffer result = new StringBuffer("");
  StringTokenizer words = new StringTokenizer(s);// Tokenize
  while (words.hasMoreTokens()) {        // Encode each word
    result.append(encode(words.nextToken()) + " ");
  }
  return result.toString();        // Return result} // encrypt()
 </input></program>
    <p>
      This method creates a local <c>StringBuffer</c> variable,
<c>result</c>, and uses <c>StringTokenizer</c> to break the original
<c>String</c> into its component words.
      It uses the <c>encode()</c> method to encode the word,
      appending the result into <c>result</c>. The result is converted back into a <c>String</c> and returned as the encrypted translation of
      <em>s</em>, the original message.
    </p>
    <p>
      If we define <c>encrypt()</c> in the superclass,
      it will be inherited  by all of <c>Cipher</c>'s subclasses.
      Thus, if we define <c>Caesar</c> and <c>Transpose</c> as
    </p>
 <program language="java"><input>
public class Caesar extends Cipher { ... }
public class Transpose extends Cipher { ... }
 </input></program>
    <p>
      instances of these classes will be able to use the <c>encrypt()</c> method.
    </p>
    <p>
      On the other hand,
      the polymorphic <c>encode()</c> method cannot be implemented within <c>Cipher</c>. This is because unlike the <c>encrypt()</c> method,
      which is the same for every <c>Cipher</c> subclass,
      the <c>encode()</c> method will be different for every subclass.
      However, by declaring the <c>encode()</c> method as <c>abstract</c>, we can leave its implementation up to the <c>Cipher</c> subclasses.
      Thus, within the
<c>Cipher</c> class,
      we would define <c>encode()</c> and <c>decode()</c> as follows:
    </p>
 <program language="java"><input>
// Abstract methods
public abstract String encode(String word);
public abstract String decode(String word);
 </input></program>
    <p>
      These declarations within the <c>Cipher</c> class tell the compiler that these methods will be implemented in <c>Cipher</c>'s subclasses.
      By defining it as <c>abstract</c>, <c>encode()</c> can be used in the <c>Cipher</c> class,
      as it is within the <c>encrypt()</c> method.
    </p>
  </introduction>
  <subsection>
    <title>Class Design: <c>Caesar</c></title>
    <p>
      <xref ref="fig-cipher">Figure</xref>
      provides the full definition of the
<c>Cipher</c> class.
      The encode() and <c>decode()</c> methods are declared abstract.
      They are intended to be implemented by
<c>Cipher</c>'s subclasses.
    </p>
    <figure xml:id="fig-cipher">
      <caption>The <c>abstract Cipher</c> class.</caption>
      
 <program language="java"><input>
import java.util.*;
public abstract class Cipher {
  public String encrypt(String s) {
    StringBuffer result = new StringBuffer("");         // Use a StringBuffer
    StringTokenizer words = new StringTokenizer(s); // Break s into its words
    while (words.hasMoreTokens()) {                     // For each word in s
      result.append(encode(words.nextToken()) + " ");   //  Encode it
    }
    return result.toString();                            // Return the result
  } // encrypt()
  public String decrypt(String s) {
    StringBuffer result = new StringBuffer("");        // Use a StringBuffer
    StringTokenizer words = new StringTokenizer(s);    // Break s into words
    while (words.hasMoreTokens()) {                    // For each word in s
      result.append(decode(words.nextToken()) + " ");  //  Decode it
    }
    return result.toString();                       // Return the decryption
  } // decrypt()
  public abstract String encode(String word);            // Abstract methods
  public abstract String decode(String word);} // Cipher
 </input></program>
    </figure>
    <p>
      Note again that <c>encrypt()</c> and <c>decrypt()</c>, which are implemented in Cipher , invoke <c>encode()</c> and <c>decode()</c>,  respectively,
      which are declared in <c>Cipher</c> but implemented in <c>Cipher</c>'s subclasses.
      Java's dynamic binding mechanism will take care of invoking the appropriate implementation of
<c>encode()</c> or <c>decode()</c>, depending on what type of object is involved.
      For example,
      if <c>caesar</c> and <c>transpose</c> are <c>Caesar</c> and <c>Transpose</c> objects,
      respectively,
      then the following calls to <c>encrypt()</c> will cause their respective <c>encode()</c> methods to be invoked:
    </p>
 <program language="java"><input>
// Invokes caesar.encode()
caesar.encrypt("hello world");
// Invokes transpose.encode()
transpose.encrypt("hello world");
 </input></program>
    <p>
      When <c>caesar.encrypt()</c> is called,
      it will in turn invoke <c>caesar.encode()</c><mdash/>that is,
      it will call the
<c>encode()</c> method implemented in the <c>Caesar</c> class.
      When
<c>transpose.encrypt()</c> is invoked,
      it will in turn invoke
<c>transpose.encode()</c>. In this way,
      each object can perform the encoding algorithm appropriate for its type of  cipher.
    </p>
  </subsection>
  <subsection>
    <title>Algorithm Design: Shifting Characters</title>
    <p>
      The <c>Caesar</c> class is defined as an extension of <c>Cipher</c>(Fig.
      <xref ref="fig-caesar"></xref>).
      The only methods implemented in <c>Caesar</c> are <c>encode()</c> and <c>decode()</c>. The <c>encode()</c> method takes a <c>String</c> parameter and returns a <c>String</c> result.
      It takes each character of its parameter (<c>word.charAt(k)</c>) and performs a Caesar shift on the character.
      Note how the shift is done:
    </p>
 <program language="java"><input>
ch = (char)('a' + (ch -'a'+ 3) % 26);// Caesar shift
 </input></program>
    <p>
      Recall from Chapter<nbsp/>5 that <c>char</c> data in Java are represented as 16-bit integers.
      This enables us to manipulate characters as numbers.
      Thus, to shift a character by 3, we simply add 3 to its integer representation.
    </p>
    <figure xml:id="fig-caesar">
      <caption>The <c>Caesar</c> class.</caption>
      
 <program language="java"><input>
public class Caesar extends Cipher {
  public String encode(String word) {
    StringBuffer result = new StringBuffer(); // Initialize a string buffer
    for (int k = 0; k &lt; word.length(); k++) { // For each character in word
      char ch = word.charAt(k);               //  Get the character
      ch = (char)('a' + (ch -'a'+ 3) % 26);   //  Perform caesar shift
      result.append(ch);                   //  Append it to new string
    }
    return result.toString();              // Return the result as a string
  } // encode()
  public String decode(String word) {
    StringBuffer result = new StringBuffer(); // Initialize a string buffer
    for (int k = 0; k &lt; word.length(); k++) { // For each character in word
    char ch = word.charAt(k);                 //  Get the character
       ch = (char)('a' + (ch - 'a' + 23) % 26); //  Perform reverse shift
       result.append(ch);                     //  Append it to new string
    }
    return result.toString();            // Return the result as a string
  } // decode()} // Caesar
 </input></program>
    </figure>
    <p>
      For example,
      suppose that the character (<c>ch</c>) is <em>h</em>,
      which has  an ASCII code of 104
      (see Table<nbsp/>5.13).
      We want to shift it by 3, giving
      <em>k</em>, which has a code of 107.
      In this case,
      we could simply add 3 to 104 to get the desired result.
      However, suppose that <c>ch</c> was the character <em>y</em>,
      which has an ASCII code of 121.
      If we simply add 3 in this case,
      we get 124, a code that corresponds to the symbol
      <q>|,</q>
      which is not our desired result.
      Instead, we want the shift in this case to
      <q>wrap around</q>
      to the beginning of the alphabet,
      so that <em>y</em> gets shifted into <em>b</em>.
      In order to accomplish this we need to do some modular arithmetic.
    </p>
    <p>
      Let's suppose the 26 characters
      <em>a</em> to <em>z</em>
      were numbered 0 through 25,
      so that <em>a</em> corresponds to 0, <em>b</em>
      to 1, and so on up to <em>z</em> as 25.
      If we take any number <em>N</em>
      and divide it (modulo 26),
      we would get a number between 0 and 25.
      Suppose, for example, <em>y</em> were numbered 24.
      Shifting it by 3 would give us 27,
      and <c>27 % 26</c> would give us 1, which corresponds to <em>b</em>.
      So, if the <em>a</em> to <em>z</em>
      were numbered 0 through 25,
      then we can shift any character within that range by using the following formula:
    </p>
 <program language="java"><input>
(ch + 3) % 26         // Shift by 3 with wraparound
 </input></program>
    <p>
      To map a character in the range
      <em>a</em> to <em>z</em>
      onto the integers 0 to 25,
      we can simply subtract <em>a</em> from it:
    </p>
 <program language="java"><input>
'a' - 'a' = 0
'b' - 'a' = 1
'c' - 'a' = 2
...
'z' - 'a' = 25
 </input></program>
    <p>
      Finally, we simply map the numbers 0 through 25 back to the characters
      <em>a</em> to <em>z</em>
      to complete the shift operation:
    </p>
 <program language="java"><input>
(char)('a' + 0) = 'a'
(char)('a' + 1) = 'b'
(char)('a' + 2) = 'c'
...
(char)('a' + 25) = 'z'
 </input></program>
    <p>
      Note the use here of the cast operator <c>(char)</c> to covert an integer into a <c>char</c>.
    </p>
    <p>
      To summarize,
      we can shift any character by 3 if we map it into the range 0 to 25, then add 3 to it mod 26,
      then map that result back into  the<nbsp/>range
      <em>a</em> to <em>z</em>.
      Thus, shifting <em>y</em> would go as follows:
    </p>
 <program language="java"><input>
(char)('a' + (ch -'a'+ 3) % 26)   //  Perform Caesar shift
(char)('a' + ('y' - 'a' +3) % 26) //   on 'y'
(char)(97 + (121 - 97 + 3) % 26)      //  Map 'y' to 0..25
(char)(97 + (27 % 26))     //  Shift by 3, wrapping around
(char)(97 + 1)           //  Map result back to 'a' to 'z'
(char)(98)                    //  Convert from int to char
'b'
 </input></program>
    <p>
      Note that in <c>decode()</c> a reverse Caesar shift is done by shifting by 23, which is <m>26-3</m>.
      If the original shift is 3, we can reverse that by shifting an additional 23.
      Together this gives a shift of 26,
      which will give us back our original string.
    </p>
  </subsection>
  <subsection>
    <title>Class Design: <c>Transpose</c></title>
    <p>
      The <c>Transpose</c> class (Fig.
      <xref ref="fig-transpose"></xref>) is structured the same as the <c>Caesar</c> class.
      It implements both the
<c>encode()</c> and <c>decode()</c> methods.
      The key element here is the transpose operation,
      which in this case is a simple reversal of the letters in the word.
      Thus,
      <q>hello</q>
      becomes
      <q>olleh</q>. This is very easy to do when using the <c>StringBuffer.reverse()</c> method.
      The
<c>decode()</c> method is even simpler,
      because all you need to do in this case is call <c>encode()</c>. Reversing the reverse of a string gives you back the original string.
    </p>
    <figure xml:id="fig-transpose">
      <caption>The <c>Transpose</c> class<idx><h>Transpose class</h></idx>.</caption>
 <program language="java"><input>
public class Transpose extends Cipher {
  // encode() reverses and returns a word
  public String encode(String word) {
    StringBuffer result = new StringBuffer(word);
    return result.reverse().toString();
  } // encode()
  public String decode(String word) {
    return encode(word);         // Just call encode
  } // decode} // Transpose
 </input></program>
    </figure>
  </subsection>
  <subsection xml:id="self-study-exercisesF22">
    <title>Testing and Debugging</title>
    <p>
      <xref ref="fig-testcipher">Figure</xref>
      provides a simple test program for testing
<c>Cipher</c> and its subclasses.
      It creates a <c>Caesar</c> cipher and
    </p>
    <figure xml:id="fig-testcipher">
      <caption>The <c>TestEncrypt</c> class<idx><h>TestEncrypt class</h></idx>.</caption>
      
 <program language="java"><input>
public class TestEncrypt {
  public static void main(String argv[]) {
    Caesar caesar = new Caesar();
    String plain = "this is the secret message";   // Here's the message
    String secret = caesar.encrypt(plain);         // Encrypt the message
    System.out.println(" ********* Caesar Cipher Encryption *********");
    System.out.println("PlainText: " + plain);    // Display the results
    System.out.println("Encrypted: " + secret);
    System.out.println("Decrypted: " + caesar.decrypt(secret));// Decrypt
    Transpose transpose = new Transpose();
    secret = transpose.encrypt(plain);
    System.out.println("\n ********* Transpose Cipher Encryption *********");
    System.out.println("PlainText: " + plain);    // Display the results
    System.out.println("Encrypted: " + secret);
    System.out.println("Decrypted: " + transpose.decrypt(secret));// Decrypt
  } // main()} // end TestEncrypt
 </input></program>
    </figure>
    <p>
      a <c>Transpose</c> cipher and then encrypts and decrypts the same sentence using each cipher.
      If you run this program, it will produce the following output:
    </p>
 <program language="java"><input>
********* Caesar Cipher Encryption *********
    PlainText: this is the secret message
    Encrypted: wklv lv wkh vhfuhw phvvdjh
    Decrypted: this is the secret message
     ********* Transpose Cipher Encryption *********
    PlainText: this is the secret message
    Encrypted: siht si eht terces egassem
    Decrypted: this is the secret message
 </input></program>
    </subsection><subsection><title>Self-Study Exercises</title>
      <ol>
        <li>
          <p>
            Modify the <c>Caesar</c> class so that it will allow various sized shifts to be used.
            (<em>Hint</em>: Use an instance variable to represent the shift.)
          </p>
        </li>
        <li>
          <p>
            Modify <c>Transpose.encode()</c> so that it uses a rotation instead of a reversal.
            That is, a word like
            <q>hello</q>
            should be encoded as
            <q>ohell</q>
            with a rotation of one character.
          </p>
        </li>
      </ol>
  </subsection>
</section>