<section xml:id="sec-passby">
  <title>Passing a Value and Passing a Reference</title>
  <introduction>
  <p>
    The effect of passing arguments to a method differs depending on whether you are passing a value of primitive type
        <idx><h>primitive type</h></idx>
    (such as 5 or <c>true</c>) or a value of reference type
        <idx><h>reference type</h></idx>
    (such as
    <q>Hello</q>
    or <c>game1</c>).
    </p>
  </introduction>
  <subsection><title>Primitive Types: Pass by Value</title>
   <p> When an argument of primitive type is  passed to a method,
    a copy of the argument is passed to the formal     parameter.
    For example,
    consider the PrimitiveCall class shown in <xref ref="fig-primcall">Figure</xref>.
    Note that we have an <c>int</c> variable <c>k</c>, which initially stores the value 5, and a method
<c>myMethod()</c>, which takes an <c>int</c> parameter <c>n</c>. In this case,
    when we invoke <c>myMethod(k)</c>, <c>k</c>'s value (5) is copied into <c>n</c> and stored there during the method.
    Run the code below to trace through it. Notice that the original variable in main does not change its value because its value is copied into the parameter variable.
  </p>
  
  <listing xml:id="fig-primcall">
    <caption>Passing a primitive value to a method.</caption>
 <program language="java"><input>
public class PrimitiveCall
{
   public static void myMethod(int n)
   {   System.out.println("myMethod: n= " + n);
       n = 100;
       System.out.println("myMethod: n= " + n);
   } // myMethod()

   public static void main(String argv[])
   {   int k = 5;
       System.out.println("main: k= " + k);
       myMethod(k);
       System.out.println("main: k= " + k);
   } // main()
 } // PrimitiveCall
 </input></program>
</listing>

<activity label="callbyvalEx">
  <statement><p>Run the code below. Click on Show CodeLens to step through the code with the Next button.
  </p></statement>
  <program language="java" interactive="activecode"><input>
    public class PrimitiveCall
    {
       public static void myMethod(int n)
       {   System.out.println("myMethod: n= " + n);
           n = 100;
           System.out.println("myMethod: n= " + n);
       } // myMethod()
    
       public static void main(String argv[])
       {   int k = 5;
           System.out.println("main: k= " + k);
           myMethod(k);
           System.out.println("main: k= " + k);
       } // main()
     } // PrimitiveCall
  </input></program></activity>
    <p>
    One implication of passing a copy of a primitive value to a method is that the original value of <c>k</c> in <c>main()</c> cannot be altered from inside the method.
    Thus, the output generated by <c>PrimitiveCall</c> is
  </p>
 <program language="java"><input>
  main: k= 5
  myMethod: n= 5
  myMethod: n= 100
  main: k= 5
 </input></program>
  <p>
    Note that in <c>main()</c>, <c>k</c>'s value is printed both before and after <c>myMethod()</c> is called,
    but that its value remains unaffected even though <c>n</c>'s value is changed within the method.
    This is because <c>myMethod()</c> contains just a <em>copy</em>
    of <c>k</c>'s value,
    not <c>k</c> itself.
    Any changes to the copy within <c>myMethod()</c> leave <c>k</c> unaltered.
  </p>
  <principle>
    <title>Passing a Primitive Value</title>
    <p>
      When a value of a primitive type,
      like <c>boolean</c> or <c>int</c> or <c>double</c>, is passed to a method,
      a copy of the value is passed.
      That's why its original value remains unchanged outside the method,
      even if the copy is changed inside the method.
    </p>
  </principle>
  <figure xml:id="fig-vparameps">
    <caption>Tracing the state of variables k and n
    in <c>PrimitiveCall</c>(a) Just
    before calling <c>myMethod(k) in main</c>. (b) Just before executing the body
    of <c>myMethod()</c>. (c) Just after executing the body of <c>myMethod()</c>. (d) After flow of control returns to <c>main()</c>.</caption>
    <image width="73%" source="chptr03/vparam.png"/>
  </figure>
  
</subsection>
  <subsection><title>Passing Reference Types</title>
  <p>
    In contrast to this,
    when an argument of a reference type, like <c>String</c> or another class type like <c>OneRowNim</c>, is passed to a method,
    a copy of the reference to the object itself is assigned to the parameter.
    For example,
    in the case of a <c>String</c> parameter or a <c>OneRowNim</c> parameter,
    the method would be given a reference to the object<ndash/>that is,
    the address of the object.
    The object itself is <em>not</em> passed,
    because it would be too inefficient to copy the entire object with all its data and methods.
    However, because the object's reference gives the object's location in memory,
    the method will have access to the object and can make changes to the original object from within the method.
  </p>
  <p>
    For example,
    consider the <c>ReferenceCall</c> class (<xref ref="fig-refcall"></xref>).
    In this case, <c>myMethod()</c> takes a  parameter <c>g</c> of type <c>OneRowNim</c>. Because a OneRowNim instance is an object, <c>g</c> is a reference variable.
    So when <c>myMethod(game)</c> is invoked in <c>main()</c>, a reference to
<c>game</c> is passed to <c>myMethod()</c>. Note that in <c>myMethod()</c>, we use <c>takeSticks(3)</c> to change the number of sticks of <c>g</c> from 10 to 7 and that this change persists even after the method returns control to <c>main()</c>. The reason is that during the method's execution,
    both <c>game</c> and <c>g</c> refer to the exact same object.
  </p>
  <listing xml:id="fig-refcall">
    <caption>Passing a reference value to a method.</caption>
 <program language="java"><input>
public class ReferenceCall
{
    public static void myMethod(OneRowNim g)
    {   System.out.print("myMethod: Number of sticks: ");
        System.out.println(g.getSticks());
        g.takeSticks(3);
        System.out.print("myMethod: Number of sticks: ");
        System.out.println(g.getSticks());
    } // myMethod()

    public static void main(String argv[])
    {   OneRowNim game = new OneRowNim(10);
         System.out.print("main: Number of sticks: ");
         System.out.println(game.getSticks());
         myMethod(game);
         System.out.print("main: Number of sticks: ");
         System.out.println(game.getSticks());
    }// main()
} // ReferenceCall
 </input></program>
</listing>

<activity label="callrefEx">
  <statement><p>Run the code below. Click on Show CodeLens to step through the code with the Next button.
  </p></statement>
  <program language="java" interactive="activecode"><input>
public class ReferenceCall
{
    public static void myMethod(OneRowNim g)
    {   System.out.print("myMethod: Number of sticks: ");
        System.out.println(g.getSticks());
        g.takeSticks(3);
        System.out.print("myMethod: Number of sticks: ");
        System.out.println(g.getSticks());
    } // myMethod()

    public static void main(String argv[])
    {   OneRowNim game = new OneRowNim(10);
         System.out.print("main: Number of sticks: ");
         System.out.println(game.getSticks());
         myMethod(game);
         System.out.print("main: Number of sticks: ");
         System.out.println(game.getSticks());
    }// main()
} // ReferenceCall

class OneRowNim
     {   private int nSticks = 7;         // Start with 7 sticks
         private int player = 1;          // Player 1 plays first
     
         public OneRowNim()
         {   nSticks = 7;
             player = 1;
         }
     
         public OneRowNim(int sticks)
         {   nSticks = sticks;
         }
     
         public void takeSticks(int num)
         {   nSticks = nSticks - num;
             player = 3 - player;
         }  
     
         public int getSticks()
         {   return nSticks;
         }
     
         public int getPlayer()
         {   return player;
         }
     
         public boolean gameOver()
         {   return (nSticks &lt;= 0);
         }
     
         public void report()
         {   System.out.println("Number of sticks left: " + nSticks);
             System.out.println("Next turn by player " + player);
         } // report()
       }
  </input> </program></activity>
  <p>
    The output generated by <c>ReferenceCall</c> would be
  </p>
 <program language="java"><input>
  main: Number of sticks: 10
  myMethod: Number of sticks: 10
  myMethod: Number of sticks: 7
  main: Number of sticks: 7
 </input></program>

  <figure xml:id="fig-rparameps">
    <caption>Tracing the state of <c>OneRowNim</c> object
    in <c>ReferenceCall</c>(a) Just
    before calling <c>myMethod(game)</c>. (b) Just before executing the body
    of <c>myMethod()</c>. (c) Just after executing the body of <c>myMethod()</c>. (d) After flow of control returns to <c>main()</c>.</caption>
    <image width="73%" source="chptr03/rparam.png"/>
  </figure>
  <p>
    This illustrates that when passing a reference variable to a method,
    it is possible for the method to change the state of the object associated with the reference variable.
    In subsequent chapters, we will see ways to make use of this feature of reference parameters.
  </p>
  <principle>
    <title>Passing a Reference</title>
    <p>
      When a reference to an object is passed to a method,
      any changes made to the object from within the method will persist when the method is finished executing.
    </p>
  </principle>
  <principle>
    <title>DEBUGGING TIP: Side Effects</title>
    <p>
      An unintended change to an object is called a <term>side effect</term>.
      Care should be taken in designing methods that the method does not produce unwanted side effects in objects passed as reference parameters.
    </p>
  </principle>
</subsection>
</section>