<section xml:id="ch-recursion-sum">
    <title>Chapter Summary</title>
    <subsection>
      <title>Technical Terms</title> 
      <p>
       <tabular>
       <row>
      <cell>base case</cell>
      <cell>recursion parameter</cell>
       </row>
       <row>
      <cell>computational overhead</cell>
      <cell>recursive case</cell>
       </row>
       <row>
      <cell>head-and-tail algorithm</cell>
      <cell>recursive definition</cell>
       </row>
       <row>
      <cell>iterative method</cell>
      <cell>recursive method</cell>
       </row>
       <row>
      <cell>last-in-first-out (LIFO)</cell>
      <cell>self-similarity</cell>
       </row>
       <row>
      <cell>method call stack</cell>
      <cell>tail recursive</cell>
       </row>
      </tabular>
    </p>
</subsection>
<subsection>
 <title>Important Points</title>
      <ul>
        <li>
          <p>
            A <em>recursive definition</em>
            is one that defines the <em>n</em>th case of a concept in terms of the <m>(n-1)</m>st case plus a limiting condition.
            It is based on the idea of breaking a problem up into smaller,
            self-similar problems.
          </p>
        </li>
        <li>
          <p>
            A <em>recursive
              <idx><h>recursive method</h></idx>
            method</em> is one that calls itself.
            It is usually defined in terms of a
            <em>base case</em> or limiting case,
            which stops the recursive process, and a recursive case,
            which breaks the method into a smaller,
            self-similar copy of itself.
            A <em>recursion parameter</em> is generally used to control the recursion.
          </p>
        </li>
        <li>
          <p>
            An iterative algorithm is one that uses some kind of loop as its control structure.
            Any algorithm that can be done iteratively can also be done recursively,
            and vice versa.
          </p>
        </li>
        <li>
          <p>
            Because method calling is relatively costly both in terms of memory used and CPU time involved,
            a recursive algorithm is generally less efficient than an iterative one that does the same thing.
          </p>
        </li>
        <li>
          <p>
            In designing recursive algorithms,
            the <em>base case</em> defines a limit.
            Each level of recursion should make progress toward the limit,
            and the algorithm should eventually reach the limit.
            The limit is usually expressed in terms of the
            <em>recursion parameter</em>.
          </p>
        </li>
        <li>
          <p>
            A recursive method is <em>tail recursive</em>
            if and only if each of its recursive calls is the last action executed by the method.
          </p>
        </li>
        <li>
          <p>
            A Swing <c>JComboBox</c> component is used to represent a GUI drop-down menu.
          </p>
        </li>
      </ul>
</subsection>

<solutions scope="chapter-recursion" divisional="solution" project="solution" inline="solution">
  <title>Solutions to Self-Study Exercises</title>
</solutions>

<!--
<subsection>
<title>Solutions to Self-Study Exercises</title>
  <p>
    <ol>
      <li>
        <p>
            The output produced by <c>mystery(0)</c> would be 0 1 2 3 4 5 6.
            The output produced by <c>mystery(100)</c> would be 100.
        </p>
      </li>
      <li>
        <p>
            The output produced by <c>mystery(5)</c> would be: 5 4 3, and so on.
            In other words, this is an infinite recursion.
        </p>
      </li>
      <li>
        <p>
             <program language="java"><input>
Definition: twoToN(N), N >= 0
  1, if N == 0                   // Base case
  2 * twoToN(N - 1),  N > 0      // Recursive case
 </input></program>
        </p>
      </li>
      <li>
        <p>
            The function <m>x^n</m> is known as the power function:
 <program language="java"><input>
Definition: power(X,N), N >= 0
  1, if N == 0                    // Base case
  X * power(X, N - 1),  N > 0     // Recursive case
 </input></program>
        </p>
      </li>
      <li>
        <p>
            Yes, the two definitions for nested boxes are equivalent.
            Suppose the square starts out with a side of 20.
            The definition given in the exercise will also draw squares with sides of 20, 15, 10, 5.
        </p>
      </li>
      <li>
        <p>
            A recursive definition for the pattern in Figure<nbsp/>12.4:
 <program language="java"><input>
Draw a square with side, s.
Inscribe a circle with diameter, s.
If s > 5,
  Draw a smaller version of same pattern. // Recursive case
 </input></program>
        </p>
      </li>
      <li>
        <p>
            The <c>printString2("hello")</c> method will print:
            <q>olleh.</q>
        </p>
      </li>
      <li>
        <p>
            A definition for <c>countDown()</c>:
 <program language="java"><input>
/** countDown(N) recursively prints a countdown
  *  beginning at N and ending at 1
  * @param N >= 1
  * Base case: N == 0
  */
void countDown(int N) {
    if (N == 0)                     // Base case
        System.out.println("blastoff");
    else {
        System.out.print(N + ", "); // Recursive case
        countDown(N - 1);
    }} // countDown()
 </input></program>
         </p>
      </li>
      <li>
        <p>
            A revised definition for <c>countDown()</c>:
 <program language="java"><input>
/** countDown(N) recursively prints a countdown
  *  beginning at N, counting every other number, 10 8 6 ...
  *  and ending at "blastoff"
  * @param N >= 1
  * Base case: N &lt;= 0
  */
void countDown(int N) {
    if (N &lt;= 0)                     // Base case
        System.out.println("blastoff");
    else {
        System.out.print(N + ", "); // Recursive case
        countDown(N - 2 );
    }} // countDown()
 </input></program>
        </p>
      </li>
      <li>
          <p>
            A method to sum the numbers from 1 to
            <em>N</em>.
 <program language="java"><input>
int sum(int N) {
    if (N == 0)
        return 0;
    else
        return N + sum(N-1);}
 </input></program>
          </p>
        </li>
        <li>
          <p>
            A method to change each blank within a string to two blanks.
 <program language="java"><input>
String addBlanks(String s) {
  if (s.length() == 0)
     return "";
  else if (s.charAt(0) == ' ')
     return ' ' + s.charAt(0) + addBlanks(s.substring(1));
  else
     return s.charAt(0) + addBlanks(s.substring(1));}
 </input></program>
          </p>
        </li>
        <li>
          <p>
            A method to print out all possible outcomes for a chess player playing <c>N</c> games. <c>printOutcomes(str, N)</c> will print all outcomes for the next <c>N</c> games given that results for previous games are stored in the string named <c>str</c>.
 <program language="java"><input>
public static void printOutcomes(String str, int N){
     if (N = 1){ // Base case: win, lose, or draw one game
         System.out.println(str + "W");
         System.out.println(str + "L");
         System.out.println(str + "D");
     } else {  // Recursive case
         printOutcomes(str + "W", N - 1);
         printOutcomes(str + "L", N - 1);
         printOutcomes(str + "D", N - 1);
     } //else
 }// printOutcomes()
 </input></program>
          </p>
        </li>
        <li>
          <p>
             <program language="java"><input>
public static void main(String args[]) {
  int numbers[] = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18};
  Searcher searcher = new Searcher();
  for (int k = 0; k &lt;= 20; k++) {
    int result = searcher.search(numbers, k);
    if (result != -1)
      System.out.println(k + " found at " + result);
    else
      System.out.println(k + " is not in the array ");
  } // for} // main()
 </input></program>
          </p>
        </li>
        <li>
          <p>
            The <c>sort()</c> method is used as a public interface to the recursive <c>selectionSort()</c> method:
 <program language="java"><input>
/** sort(arr) sorts the int array, arr
 *  Pre: arr is not null
 *  Post: arr will be arranged so that arr[j] &lt;= arr[k]
 *     for any j &lt; k
 */
public void sort(int arr[]) {
    selectionSort(arr, arr.length - 1);
             // Just call the recursive method}
 </input></program>
          </p>
        </li>
        <li>
          <p>
            An iterative version of <c>findMax()</c>:
 <program language="java"><input>
/** findMax (arr,N) returns the index of the largest
  *  value between arr[0] and arr[N], N >= 0.
  *  Pre: 0 &lt;= N &lt;= arr.length -1
  *  Post: arr[findMax()]>=arr[k] for k between 0 and N.
  */
private int findMax(int arr[], int N) {
    int maxSoFar = 0;
    for (int k = 0; k &lt;= N; k++)
        if (arr[k] > arr[maxSoFar])
            maxSoFar = k;
    return maxSoFar;} // findMax()
 </input></program>\marginfiglarge{chptr12/boxes45.eps}{Levels four and five of the nested boxes pattern.}{fig-boxes45}
          </p>
        </li>
        <li>
          <p>
            Levels four and five of the nested boxes pattern are shown in Figure<nbsp/>12.34.
          </p>
        </li>
        <li>
          <p>
            The following method will reduce the length of the side by <c>delta</c> percent at each level of recursion.
            The spacing between the boxes will vary by a constantly decreasing amount.
 <program language="java"><input>
private void  drawBoxes(Graphics g, int level, int locX,
                   int locY, int side, int delta) {
    g.drawRect(locX, locY, side, side );
    if (level > 0) {
      int dside = side * delta / 100; // Percent delta
      int newLocX = locX + dside;
      int newLocY = locY + dside;
      drawBoxes(g, level - 1, newLocX, newLocY,
                         side - 2 * dside, delta);
    }} // drawBoxes()
 </input></program>
          </p>
        </li>
        <li>
          <p>
             <program language="java"><input>
private void drawBoxesIterative(Graphics g, int level,
            int locX, int locY, int side, int delta) {
 for (int k = level; k >= 0; k- -) {
  g.drawRect(locX, locY, side, side );  // Draw a square
  locX += delta;             // Calculate new location
  locY += delta;
  side -= 2 * delta;         // Calculate new side length
 }} // drawBoxes()
 </input></program>
          </p>
        </li>
        <li>
          <p>
            The level two and three gaskets are shown in <xref ref="fig-sierpinski23">Figure</xref>.
            <figure xml:id="fig-sierpinski23">
              <caption>Levels two and three of the Sierpinski gasket.</caption>
              <image width="73%" source="chptr12/sierpinski23.png"/>
            </figure>
          </p>
        </li>
        <li>
          <p>
            The <c>printReverse()</c> method is not tail recursive because in that method the recursive call is not the last statement executed.
          </p>
        </li>
        <li>
          <p>
            The <c>countChar()</c> method is tail recursive.
            The recursive calls are not the last statements in the method definition.
            However, each of the recursive calls would be the last statement executed by the method.
          </p>
        </li>
     </ol>
  </p>
</subsection>
-->
</section>