<section xml:id="casestudy-simulatinga-two-person-game">
  <title>CASE STUDY: Simulating a Two-Person Game</title>
  <introduction>
    <p>
      In this section,
      we will design a class definition that keeps track of the details of a well known,
      two-person game.  Our objective is to understand what the program is doing and 
      how it works.
    </p>
    <p>
      The game we will consider is played by two persons with a row of sticks or coins or other objects.
      The players alternate turns. On each turn, the player must remove one,
      two, or three sticks from the row.  Whoever removes the last stick loses.
      The game can be played with any number of sticks but starting with twenty one sticks is quite common.
    </p>
    <p>  
      This game is sometimes referred to as "Nim", but there is a similar 
      game involving multiple rows of sticks that is more frequently given that name.
      Thus we will refer to our game as "One Row Nim".
    </p>
  </introduction>
  <subsection>
    <title>Designing a OneRowNim class</title>
      <project>
      <term>Specification:</term> Design a class named <c>OneRowNim</c> that simulates the game of One Row Nim with a row of sticks.
        A <c>OneRowNim</c> object should keep track of whose turn it is and allow players to <q>take away</q> one, two,
        or three sticks. It should be able to decide when the game is over and which player has won.
      </project>


    <subsubsection>
      <title>Problem Decomposition</title>
      <p>
        Let's design <c>OneRowNim</c> so that it can be used in with different kinds of user interfaces:
        <ul>
        <li><p>Person vs. persomn.</p></li>
        <li><p>Person vs. computer.</p></li>
        <li><p>Keyboard and console interface.</p></li>
        <li><p>Graphical interface.</p></li>
        </ul>
      </p>
      <p>
        In this chapter, we will work on the <c>OneRowNim</c> class.
        We will design the user interfaces in a subsequent chapter.
      </p>
    </subsubsection>
    <subsubsection>
      <title>Class Design: <c>OneRowNim</c></title>
      <p>
        As we saw in the <c>Riddle</c> example,
        class definitions are broken down into two parts: 
        <ol>
          <li><p>The information or attributes that the object needs (<term>variables</term>).</p></li>
          <li><p>The behavior or actions the object can take (<term>methods</term>).</p></li>
        </ol> 
      </p>
      <p>
        The <c>OneRowNim</c> object should manage two pieces of information  that vary as the game is played.
        One is the number of sticks remaining and the other is which player has the next turn. We can 
        represent both of these as whole numbers, which correspond to <c>int</c> in Java:
        <tabular>
          <row><cell>Variable Name</cell> <cell>Type</cell> <cell> Values</cell></row>
          <row><cell>-------------</cell> <cell> <c>----</c></cell> <cell>------</cell></row>
          <row><cell>nSticks</cell> <cell> <c> int</c></cell> <cell> 0 through 21</cell></row>
          <row><cell>player</cell> <cell> <c> int</c></cell> <cell> 1 or 2</cell></row>
        </tabular>          
      </p>
      <p>
        As this table suggests, we will represent our two players as the numbers 1 or 2.
      </p>
      <p>
        During the playing of the game, the values of these two variables will represent the state of the game:
        whose turn it is, and whose turn it is.
      </p>
    </subsubsection>
    <subsubsection xml:id="fig-ornuml">
      <title>Method Decomposition</title>
      <p>
        One action needed for our game is the taking away of 1-3 sticks. The easiest way to do this is to have 
        three methods corresponding to taking one, two,
        or three sticks: <c>takeOne()</c>, <c>takeTwo()</c>, and <c>takeThree()</c>.  Each method will be responsible 
        for reducing the value of <c>nSticks</c> as well as switching to the other <c>player</c>.
      </p>
      <p>
        (Once we learn how to use parameters and return values (next chapter), we'll be able to replace these three 
        methods with a single method that can take away 1, 2 or 3 sticks.) 
      </p>
      <p>
        We also need a method that gives the information that a user needs when considering a move.  The <c>report()</c>
        method will report the number of sticks remaining and whose turn it is.
      </p>
      <p>
        <xref ref="fig-onerownimclass">Figure</xref> is a UML class diagram that summarizes our design decisions.
        Note that the instance variables are specified as private (<m>-</m>) to hide them from other objects, and the methods 
        are specified as public (<m>+</m>) and will thereby form the <c>OneRowNim</c> interface.
        These will be the methods that other objects will use to interact with it. 
      </p>
      <figure xml:id="fig-onerownimclass">
        <caption>The <c>OneRowNim</c> class.</caption>
        <image width="30%" source="chptr02/onerow3.png"/> 
      </figure>
    </subsubsection>
  </subsection>
  <subsection>
    <title>Defining the <c>OneRowNim</c> Class</title>
    <introduction>
      <p>
        Given our design of the <c>OneRowNim</c> class as described in <xref ref="fig-onerownimclass">Figure</xref>,
        the next step in building our simulation is to begin writing the Java class definition.
      </p>
    </introduction>
    <subsubsection xml:id="fig-pedigree">
      <title>The Class Header</title>
      <p>
        The purpoe of the <term>class header</term> is
        give the class a name and specify its relationship to other classes.
        It takes the following form:
        <p>
          ClassModifiers<m>_{opt}</m> <c>class</c> ClassName Pedigree<m>_{opt}</m>
        </p>
      </p>p>
      <p>
        Because our <c>OneRowNim</c> object will interact with other objects, we will designate its access 
        as <c>public</c>. And because  <c>OneRowNim</c> is not a subclass of any other type of object, 
        we will omit the <c>extends</c> clause, thereby making it a direct subclass of <c>Object</c> by default 
        (<xref ref="fig-onerownim1">(Figure</xref>).
      </p>
      <figure xml:id="fig-onerownim1">
        <caption>By default, <c>OneRowNim</c> is a subclass of <c>Object</c>.</caption>
      <image width="20%" source="chptr02/onerow1.png"/>
      </figure>
      <p>
        This gives us the following class header for <c>OneRowNim</c>:
      </p>
     <program language="java"><input>
        public class OneRowNim  // Class header
        {                       // Beginning of class body
        }                       // End of class body
     </input></program>
    </subsubsection>
    <subsubsection>
      <title>Instance Variables</title>
      <p>
        The body of a class definition consists of  two parts:
        variables and method definitions.
        An <term>instance variable</term> is a variable that can be used throughout the class,
        which makes it a <term>class-level variable</term>.
      </p>
      <p>
        Although Java does not impose any particular order on variable and method declarations,
        in this book a class definition will take the form shown in <xref ref="fig-form">Figure</xref>.
        First we'll define the class's variables followed by its method definitions.
      </p>
      <figure xml:id="fig-form">
        <caption>A template for constructing a Java class definition.</caption>
        <program language="java"><input>
          public class ClassName
          {  // Instance variables
               VariableDeclaration1
               VariableDeclaration2
               ...
              // Instance methods
               MethodDefinition1
               MethodDefinition2
               ...
          } // End of class
        </input></program>
      </figure>
      <p>
        Instance variables are distinguished from <term>local variables</term>, which are variables defined within a method.
        Examples would be the variables <c>q</c> and <c>a</c> that were defined in the <c>Riddle(String q, String a)</c> 
        constructor (<xref ref="fig_riddle">Figure</xref>).
        As we will see better in the next chapter, Java handles each type of variable differently.
      </p>
      <p>
        A declaration for an instance variable must follow the rules for naming variables that 
        were described in <xref ref="subsec_vardecl">Section</xref>. Also, instance variables are 
        usually declared <c>private</c>, to protect them from other objects.
      </p>
      <p>
        Java provides three different access modifiers, which observe the following rules:

        <ul>
          <li>
            <p>
              A <c>private</c> element cannot be accessed outside the class in which it is declared.
            </p>
          </li>
          <li>
            <p>
              A <c>public</c> element is accessible to any other object.
            </p>
          </li>
          <li>
            <p>
              A <c>protected</c> element is accessible only within subclasses of its class and by other classes 
              that belong to the same package.
            </p>
          </li>
        </ul>
      </p>
      <p>
        Whenever  a class, instance variable, or method is defined,
        you can explicitly declare it <c>public</c>, <c>protected</c>, or <c>private</c>. Or you can leave its access unspecified,
        in which case Java's default accessibility rules will apply.
      </p>
      <!-- 
      <p>
        The <c>Riddle</c> class (<xref ref="lstng_riddleclass">Listing</xref>) that we considered earlier has the 
        following two examples of valid declarations of instance variables:
      </p>
 <program language="java"><input>
private String question;
private String answer;
 </input></program>
-->

 <subsubsection>
  <title>Default Accessibility</title>

      <p>
        Java determines <term>default accessibility</term> in a top-down manner.
        Instance variables and methods are contained in classes,
        which are contained in packages.
        To determine whether a instance variable or method is accessible, Java starts by determining whether its containing package is accessible,
        and then whether its containing class is accessible.
        Access to classes, instance variables,
        and methods is defined according to the rules shown in the table below.
      </p>
      <table>
        <title>Java's accessibility rules.</title>
        
        <tabular>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell>{Element}</cell>
            <cell>{Modifier}</cell>
            <cell>{Rule}</cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell>Class</cell>
            <cell><c>public</c></cell>
            <cell>Accessible if its package is accessible.</cell>
          </row>
          <row>
            <cell></cell>
            <cell>by default</cell>
            <cell>Accessible only within its package.</cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell>Instance variable</cell>
            <cell><c>public</c></cell>
            <cell>Accessible to all other objects.</cell>
          </row>
          <row>
            <cell><nbsp/><nbsp/> or</cell>
            <cell><c>protected</c></cell>
            <cell>Accessible to its subclasses and to</cell>
          </row>
          <row>
            <cell><nbsp/><nbsp/>instance method</cell>
            <cell></cell>
            <cell><nbsp/><nbsp/>  other classes in its package.</cell>
          </row>
          <row>
            <cell></cell>
            <cell><c>private</c></cell>
            <cell>Accessible only within the class.</cell>
          </row>
          <row>
            <cell></cell>
            <cell>by default</cell>
            <cell>Accessible only within the package.</cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
        </tabular>
      </table>
  </subsubsection>
      <!--
      <p>
        Recall the distinction we made in Chapter 0 between class variables and instance variables.
        A class variable is associated with the class itself,
        whereas an instance variable is associated with each of the class's instances.
        In other words,
        each object contains its own copy of the class's instance variables,
        but only the class itself contains the single copy of a class variable.
        To designate a variable as a class variable it must be declared <c>static</c>.
      </p>
    -->
<!--
    </subsubsection>
    <subsubsection>
      <title>Class Level Variables for <c>OneRowNim</c></title>
    -->
      <p>
        Given our design for the <c>OneRowNim</c> class as described in 
        <xref ref="fig-onerownimclass">Figure</xref>, we get the following declarations
        for our instance variables:
 <!--       
        contains all the information we need.
        The variables <c>nSticks</c> and <c>player</c> will store data for playing one game of One Row Nim,
        so they should clearly be private instance variables.
        They both will store integer values,
        so they should be declared as variables of type <c>int</c>. Because we wish to start a game of One Row Nim using 7 sticks with player one making the first move,
        we will assign 7 as the initial value for <c>nSticks</c> and 1 as the initial value for <c>player</c>. If we add the declarations for our instance variable declarations to the class header for the <c>OneRowNim</c> class,
        we get the following:
 -->
      </p>
 <program language="java"><input>
public class OneRowNim
{
  private int nSticks = 7;
  private int player = 1;

  //Method definitions go here
} // OneRowNim
 </input></program>
<p>
  Our initializations of the variables indicate that the game will start with 7 sticka and player
  1 will go first. 
</p>
<!--
 <p>
        To summarize, despite its apparent simplicity,
        a class level variable declaration actually accomplishes five tasks:
      </p>
      <ul>
      <li><p>Sets aside a portion of the object's memory that can be used to store a certain type of data.</p></li>
      <li><p>Specifies the type of data that can be stored in that location.</p></li>
      <li><p>Associates an identifier (or name) with that location.</p></li>
      <li><p>Determines which objects have access to the variable's name.</p></li>
      <li><p>Assigns an initial value to the location.</p></li>
      </ul>
    -->
    </subsubsection>
    <subsubsection>
      <title><em>OneRowNim</em>'s Methods</title>
      <p>
        Designing and defining methods is a form of abstraction.
        By defining a certain sequence of actions as a method,
        you encapsulate those actions under a single name that can be invoked whenever needed.
        Instead of having to list the entire sequence again each time you want it performed,
        you simply call it by name.
        As you recall from Chapter 1, a method definition consists of two parts,
        the method header and the method body.
        The method header declares the name of the method and other general information about the method.
        The method body contains the executable statements that the method performs.
      </p>
 <program language="java"><input>
public void methodName()  // Method header
{                  // Beginning of method body
}                  // End of method body
 </input></program>
    </subsubsection>
    <subsubsection>
      <title>The Method Header</title>
      <p>
        The method header follows a general format that consists of one or more
        <em>MethodModifiers</em>,
        the method's <em>ResultType</em>, the <em>MethodName</em>,
        and the method's <em>FormalParameterList</em>,
        which is enclosed in parentheses.
        The following table illustrates the method header form,
        and includes several examples of method headers that we have already encountered.
        The method body follows the method header.
      </p>
      <table>
        
        <tabular>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell>MethodModifiers<m>_{opt}</m></cell>
            <cell>ResultType</cell>
            <cell>MethodName</cell>
            <cell>(FormalParameterList)</cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell><c>public</c><c>static</c></cell>
            <cell><c>void</c></cell>
            <cell><c>main</c></cell>
            <cell><c>(String argv[])</c></cell>
          </row>
          <row>
            <cell><c>public</c></cell>
            <cell><c>void</c></cell>
            <cell><c>paint</c></cell>
            <cell><c>(Graphics g)</c></cell>
          </row>
          <row>
            <cell><c>public</c></cell>
            <cell></cell>
            <cell><c>Riddle</c></cell>
            <cell><c>(String q, String a)</c></cell>
          </row>
          <row>
            <cell><c>public</c></cell>
            <cell><c>String</c></cell>
            <cell><c>getQuestion</c></cell>
            <cell><c>()</c></cell>
          </row>
          <row>
            <cell><c>public</c></cell>
            <cell><c>String</c></cell>
            <cell><c>getAnswer</c></cell>
            <cell><c>()</c></cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
        </tabular>
      </table>
      <p>
        The rules on method access are the same as the rules on instance variable access: <c>private</c> methods are accessible only within the class itself, <c>protected</c> methods are accessible only to subclasses of the class in which the method is defined and to other classes in the same package,
        and <c>public</c> methods are accessible to all other classes.
      </p>
      <principle>
        <title>EFFECTIVE DESIGN: Public vs. Private Methods</title>
        <p>
          If a method is used to communicate with an object,
          or if it passes information to or from an object,
          it should be declared <c>public</c>. If a method is intended to be used solely for internal operations within the object,
          it should be declared <c>private</c>. Private methods are sometimes called
          <term>utility methods</term>
          or <term>helper methods</term>.
        </p>
      </principle>
  <!--
      <p>
        Recall the distinction from Chapter 0 between instance methods and class methods.
        Methods declared at the class level are assumed to be instance methods unless they are also declared <c>static</c>. The
        <em>static modifier</em>
        is used to declare that a class method or variable is associated with the class itself,
        rather than with its instances.
        Just as for <c>static</c> variables,
        methods that are declared <c>static</c> are associated with the class and are therefore called <em>class methods</em>.
        As its name implies,
        an instance method can only be used in association with an object
        (or instance)
        of a class.
        Most of the class-level methods we declare will be instance methods.
        Class methods are used only rarely in Java and mainly in situations where it is necessary to perform some kind calculation before objects of the class are created.
        We will see examples of class methods when we discuss the <c>Math</c> class,
        which has such methods as <c>sqrt(N)</c> to calculate the square root of <em>N</em>.
      </p>
      <principle>
        <title>PROGRAMMING TIP:Class versus Instance Methods</title>
        <p>
          If a method is designed to be used by an object,
          it is referred to as an instance method.
          No modifier is needed to designate an instance method.
          Class methods,
          which are used infrequently compared to instance methods,
          must be declared <c>static</c>.
        </p>
      </principle>
    -->
      <listing xml:id="list-ornmheaders">
        <caption>The Instance variables and method headers for the <c>
OneRowNim</c> class.</caption>
 <program language="java"><input>
public class OneRowNim
{ private int nSticks = 7; // Start with 7 sticks.
  private int player = 1;  // Player 1 plays first.

  public void takeOne(){ } // Method bodies still need
    public void takeTwo(){ } //  to be defined.
    public void takeThree(){ }
  public void report(){ }
} //OneRowNim class
 </input></program>
      </listing>
      <p>
        Because all four of the <c>OneRowNim</c> instance methods are meant to communicate with other
        objects, they should all be declared <c>public</c>. All four methods will receive no data when 
        being called and will not return any values.
        Thus they should all have <c>void</c> as a return type and should all have empty parameter lists.
        <xref ref="list-ornmheaders">Listing</xref>> shows the code with these method headers added.
<!-- 
        They all perform actions associated with a particular instance of <c>OneRowNim</c>. That is,
        they are all used to manage a particular One Row Nim game.
        Moreover, all four methods should be declared <c>public</c>, because they are designed for communicating 
        with other objects rather than for performing internal calculations.
        Three of the methods are described as changing the values of the instance variables <c>nSticks</c> an 
        <c>player</c> and the fourth, <c>report()</c>, writes information to the console.
       </p>
      <p>
        Given these design decisions,
        we now can add method headers to our class definition of <c>OneRowNim</c>, in <xref ref="fig-ornmheaders">Figure</xref>.
      -->
      </p>
    </subsubsection>
    <subsubsection>
      <title>The Method Body</title>
      <p>
        The body of a method definition is a block of Java  statements enclosed by braces, which are executed 
        in sequence when the method is called.
        The <c>takeOne()</c> method, which represents the act of taking away one stick,  should
        reduce the value stored in <c>nSticks</c> by one and change the value in <c>player</c> from 2 to 1 or from 1 to 2.
        The first of these changes is accomplished by the following assignment:
      </p>
 <program language="java"><input>
nSticks = nSticks - 1;
 </input></program>
      <p>
        This statement says subtract 1 from the value stored in <c>nSticks</c> and assign the new value back to <c>nSticks</c>.
      </p>
      <p>
        Deciding how to change the value in <c>player</c> is more difficult because we do not know whether its current 
        value is 1 or 2.
        If its current value is 1, its new value should be 2;
        if its current value is 2, its new value should be 1.
        Notice, however,
        that in both cases the current value plus the desired new value are equal to 3.
        Therefore, the new value of <c>player</c> will always be equal to 3 minus its current value.
        Writing this as an assignment we have:
      </p>
 <program language="java"><input>
player = 3 - player;
 </input></program>
      <p>
        The following table can be used to verify that this assignment will switch players from 1 to 2 and vice versa:
        <tabular>
          <row><cell>Current player</cell><cell>3 - player</cell><cell>New player</cell></row>
          <row><cell>--------------</cell><cell>----------</cell><cell>----------</cell></row>
          <row><cell>1</cell><cell>3-1=2</cell><cell>2</cell></row>
          <row><cell>2</cell><cell>3-2=1</cell><cell>1</cell></row>
        </tabular>
<!--
        assigns 2 to <c>player</c> if its current value is 1 and assigns 1 to it if its current value is 2.
        In effect, this assignment will toggle the value off <c>player</c> between 1 and 2 each time it is executed.
        In the next chapter we will introduce the <c>if-else</c> control 
        structure that would allow us to accomplish this same toggling action in a more straightforward manner.
-->
        The complete definition of <c>takeOne()</c> method becomes:
      </p>
 <program language="java"><input>
public void takeOne()
{
   nSticks = nSticks - 1;  // Take one stick
   player = 3 - player;    // Change to other player
}
 </input></program>
      <p>
        The <c>takeTwo()</c> and <c>takeThree()</c> methods are 
        completely analogous to the <c>takeOne()</c> method with the only difference being the 
        amount subtracted from <c>nSticks</c>.
      </p>
      <p>
        The <c>report()</c> method should print the current values of the 
        instance variables using <c>System.out.println()</c>, with some additional text
        to clarufy the meaning of the values.
        Thus the body of <c>report()</c> could contain:
      </p>
 <program language="java"><input>
System.out.println("Number of sticks left: " + nSticks);
System.out.println("Next turn by player " + player);
 </input></program>
      <p>
        This completes the method bodies of the <c>OneRowNim</c> class.
        The completed class definition is shown in <xref ref="list-orndef">Listing</xref>.
      </p>
      <listing xml:id="list-orndef">
        <caption>The <c>OneRowNim</c> class definition.</caption>
        
 <program language="java"><input>
public class OneRowNim
{ private int nSticks = 7; // Start with 7 sticks.
  private int player = 1;  //Player 1 plays first.

  public void takeOne()
  { nSticks = nSticks - 1;
    player = 3 - player;
  } // takeOne()

  public void takeTwo()
  { nSticks = nSticks - 2;
    player = 3 - player;
  } // takeTwo()

  public void takeThree()
  { nSticks = nSticks - 3;
    player = 3 - player;
  }  // takeThree()

  public void report()
  { System.out.println("Number of sticks left: " + nSticks);
    System.out.println("Next turn by player " + player);
  }   // report()
} // OneRowNim1 class
 </input></program>
</listing>
      <p>
        We will discuss alternative methods for this class in the next chapter.
        In Chapter 4, we will develop several One Row Nim user interface classes that will 
        facilitate a user indicating certain moves to make.
      </p>
    </subsubsection>
  </subsection>
  <subsection xml:id="self-study-exercisesC10">
    <title>Testing the <c>OneRowNim</c>Class</title>
    <p>
  <!--
      Recall our <em>define, create,
      and use</em> mantra from <xref ref="sect-mantra">Section</xref>.
      Now that we have defined the <c>OneRowNim</c> class,
      we can test whether it works correctly by creating
<c>OneRowNim</c> objects and using them to perform the actions associated with the game.
      At this point,
  -->
      We can test <c>OneRowNim</c> by defining a <c>main()</c> method.
      Following the design we used in the riddle example,
      we will locate the <c>main()</c> method in a separate,
      user-interface class,
      named <c>OneRowNimTester</c>.
    </p>
    <p>
      The body of <c>main()</c> should declare a variable of type <c>OneRowNim</c> and create a 
      <c>OneRowNim</c>object. Let's name the variable <c>game</c>.
      To test the <c>OneRowNim</c> class,
      we should code a series of moves.
      For example,
      three moves taking 3, 3, and 1 sticks respectively would be one way to remove 7 sticks and end the game.
      Also, executing the <c>report()</c> method before the first move and after each move should 
      display the current state of the game in the console window so that we can determine whether it is working correctly.
    </p>
    <p>
      The following pseudocode outlines an appropriate sequence of statements in a <c>main()</c> method:
    </p>
    <pre>
      Declare a variable of type OneRowNim named game.
      Instantiate a OneRowNim object to which game refers.
      Tell game to report.
      Tell game to remove three sticks.
      Tell game to report.
      Tell game to remove three sticks.
      Tell game to report.
      Tell game to remove one stick.
      Tell game to report.
    </pre>
    <p>
      It is now an easy task to convert the steps in the pseudocode outline into Java statements.
      The resulting <c>main()</c> method is shown with the complete definition of the <c>OneRowNimTester</c> class:
    </p>
 <program language="java"><input>
public class OneRowNimTester
{ public static void main(String args[])
  {   OneRowNim1 game = new OneRowNim();
      game.report();
      game.takeThree();
      game.report();
      game.takeThree();
      game.report();
      game.takeOne();
      game.report();
  } //main()
}
 </input></program>
    <p>
      When it is run, <c>OneRowNimTester</c> produces the following output:
    </p>

<pre>
    Number of sticks left: 7
    Next turn by player 1
    Number of sticks left: 4
    Next turn by player 2
    Number of sticks left: 1
    Next turn by player 1
    Number of sticks left: 0
    Next turn by player 2
</pre>
    <p>
      This output indicates that player 1 removed the final stick and so player 2 is the winner of this game.
    </p>

      </subsection><subsection><title>Self-Study Exercises</title>
      <p>
      <ol>
        <li>
          <p>
            Add a new declaration to the <c>Riddle</c> class for a <c>private String</c> instance variable named <c>hint</c>. Assign the variable an initial value of <c>"This riddle is too easy for a hint"</c>.
          </p>
        </li>
        <li>
          <p>
            Write a header for a new method definition for <c>Riddle</c> named <c>getHint()</c>. Assume that this method requires no parameters and that it simply returns the <c>String</c> value stored in the <c>hint</c> instance variable.
            Should this method be declared <c>public</c> or <c>private</c>?
          </p>
        </li>
        <li>
          <p>
            Write a header for the definition of a new <c>public</c> method for
<c>Riddle</c> named <c>setHint()</c> which sets the value of the <c>hint</c> instance variable to whatever <c>String</c> value it receives as a parameter.
            What should the result type be for this method?
          </p>
        </li>
        <li>
          <p>
            Create a partial definition of a <c>Student</c> class.
            Create instance variables for the first name,
            last name, and an integer student identification number.
            Write the headers for three methods.
            One method uses three parameters to set values for the three instance variables.
            One method returns the student identification number.
            The last method returns a <c>String</c> containing the student's first name and last name.
            Write only the headers for these methods.
          </p>
        </li>
      </ol>
    </p>
  </subsection>
  <subsection xml:id="sec-methodcall">
    <title>Flow of Control: Method Call and Return</title>
    <p>
      A program's <term>flow of control</term>
      is the order in which its statements are executed.
      In an object-oriented program,
      control passes from one object to another during the program's execution.
      It's important to have a clear understanding of this process.
    </p>
    <p>
      In order to understand a Java program,
      it is necessary to understand the
      <term>method call and return</term> mechanism.
      We will encounter it repeatedly.
      A method call causes a program to transfer control to a statement located in another method.
      <xref ref="fig-methodcall">Figure</xref>
      shows the method call and return structure.
    </p>
    <figure xml:id="fig-methodcall">
      <caption>The method call and return control structure.
      It's important to realize that <c>method1()</c> and <c>method2()</c> may
      be contained in different classes.</caption>
      <image width="40%" source="chptr02/2f16.png"/>
    </figure>
    <p>
      In this example, we have two methods.
      We make no assumptions about where these methods are in relation to each other.
      They could be defined in the same class or in different classes.
      The <c>method1()</c> method executes sequentially until it calls <c>method2()</c>. This transfers control to the first statement in <c>method2()</c>. Execution continues sequentially through the statements in <c>method2()</c> until the <c>return</c> statement is executed.
    </p>
    <principle>
      <title>Return Statement</title>
      <p>
        The <c>return</c> statement causes a method to return control to the
        <term>calling statement</term><mdash/>that is,
        to the statement that called the method in the first place.
      </p>
    </principle>
    <p>
      Recall that if a <c>void</c>
          <idx><h>void</h></idx>
      method does not contain a <c>return</c> statement,
      then control will  automatically return to the calling statement after the invoked method executes its last statement.
    </p>
  </subsection>
  <subsection xml:id="subsect-trace">
    <title>Tracing the <c>OneRowNim</c>Program</title>
    <p>
      To help us understand the flow of control in <c>OneRowNim</c>, we will perform a trace of its execution.
      <xref ref="fig-trace">Figure</xref>
      shows all of the Java code involved in the program.
      In order to simplify our trace,
      we have moved the <c>main()</c> method from <c>OneRowNimTester</c> to the <c>OneRowNim</c> class.
      This does not affect the program's order of execution in any way.
      The listing in <xref ref="fig-trace">Figure</xref>
      adds line numbers to the program to show the order in which its statements are executed.
    </p>
    <figure xml:id="fig-trace">
      <caption>A trace of the <c>OneRowNim</c> program.</caption>
 <program language="java"><input>
public class OneRowNim
2 {  private int nSticks = 7; // Start with 7 sticks.
3    private int player = 1;  //Player 1 plays first.
      public void takeOne()
20    {  nSticks = nSticks - 1;
21       player = 3 - player;
      } // takeOne()
      public void takeTwo()
      {  nSticks = nSticks - 2;
         player = 3 - player;
      } // takeTwo()
      public void takeThree()
8,14  {  nSticks = nSticks - 3;
9,15     player = 3 - player;
      }  // takeThree()
      public void report()
5,11,17,23 { System.out.println("Number of sticks left: " + nSticks);
6,12,18,24   System.out.println("Next turn by player " + player);
      }   // report()
      public static void main(String args[])
1     {  OneRowNim1 game = new OneRowNim1();
4        game.report();
7        game.takeThree();
10       game.report();
13       game.takeThree();
16       game.report();
19       game.takeOne();
22       game.report();
23     } //main()
   } //OneRowNim1 class
 </input></program>
    </figure>
    <p>
      Execution of the <c>OneRowNim</c> program begins with the first statement in the <c>main()</c> method,
      labeled with line number 1.
      This statement declares a variable of type <c>OneRowNim</c> 
      named <c>game</c> and calls a constructor <c>OneRowNim()</c> to create and initialize it.
    
      The constructor causes control to shift to the declaration of the instance variables <c>nSticks</c> and 
      <c>player</c> in statements 2 and 3, and assigns them initial values of 7 and 1 respectively.
      Control then shifts back to the second statement in <c>main()</c>, which has the label 4.
    </p>
    <figure xml:id="fig-gstate1">
      <caption>The iniyial state of <c>game</c>.</caption>
      <image width="40%" source="chptr02/gstate1.png"/>
    </figure>
    <p>
      At this point, <c>game</c> refers to an instance of the <c>OneRowNim</c> class 
      with an initial state shown in <xref ref="fig-gstate1">Figure</xref>.
      Executing statement 4 causes control to shift to the <c>report()</c> method where 
      statements 5 and 6 use <c>System.out.println()</c> to write the following statements to the console.
    </p>
 <pre>
Number of sticks left: 7
Next turn by player 1
 </pre>
    <p>
      Control shifts back to statement 7 in the <c>main()</c> method,
      which calls the <c>takeThree()</c> method,
      sending control to the first statement of that method.
    </p>
    <p>
      Executing statement 8 causes <m>3</m> to be subtracted from <c>nSticks</c>, leaving the 
      value of <m>4</m>. Executing statement 9 assigns the value <m>2</m>  to <c>player</c>, leading to
      the state shown in <xref ref="fig-gstate2">Figure</xref>. 
    </p>
    <p>
      Tracing the remainder of the program follows in a similar manner.
      Notice that the <c>main()</c> method calls <c>game.report()</c> four different 
      times so that the two statements in the <c>report()</c> method are both executed on four different occasions.
      Note also that there is no call of <c>game.takeTwo()</c> in <c>main()</c>. As a result,
      the two statements in that method are never executed.
    </p>
    <figure xml:id="fig-gstate2">
      <caption>The iniyial state of <c>game</c> after line 9 is executed.</caption>
      <image width="40%" source="chptr02/gstate2.png"/>
    </figure>
  </subsection>
  <subsection>
    <title>Object-Oriented Design: Basic Principles</title>
    <p>
      We complete our discussion of the design and this first 
      implementation of the <c>OneRowNim</c> class with a brief review of some 
      of the object-oriented design principles that were employed in this example.
      <ul>
        <li>
          <p>
            <em>Encapsulation.</em> The <c>OneRowNim</c> class was designed to simulate playing the One Row Nim game. As
            such it encapsulate a certain state and a certain set of actions.
            In addition, its methods were designed to encapsulate the actions that make up their particular tasks.
        </p>
          </li>
          <li>
          <p>
            <em>Information Hiding.</em> <c>OneRowNim</c>'s instance variables, <c>nSticks</c> and <c>player</c> are 
            declared <c>private</c> and can only be changed through the class's public methods.
          </p>
          </li>
          <li>
          <p>
            <em>Clearly Designed Interface.</em> <c>OneRowNim</c>'s interface is defined in terms of its public methods,
            which constrain the way users can interact with <c>OneRowNim</c> objects. This 
            ensures that <c>OneRowNim</c> instances remain in a valid state.
          </p>
          </li>
      </ul>
    </p>
    <p>
      The <c>OneRowNim</c> class has some obvious shortcomings that are a 
      result of our decision to limit methods to those without parameters or return values.
      These shortcomings include:
      <ul>
        <li>
          <p>
            A <c>OneRowNim</c> has no way communicate how many sticks remain or whose turn it is,
            other than by writing a report to the console.
          </p>
        </li>
        <li>
          <p>
            The <c>takeOne()</c>, <c>takeTwo()</c> and <c>takeThree()</c> methods all have similar definitions.
            It would be a better design a single method that could take away a specified number of sticks.
          </p>
        </li>
        <li>
          <p>
            There is no way to start OneRowNim with a different number of sticks.
            It would be nice to have a way of playing that starts with any number of sticks.
          </p>
        </li>
        <li>
          <p>
            In order to for a user to play a <c>OneRowNim</c> game,
            a user interface class would need to be developed that would allow 
            the user to receive information about the state of the game and to input moves to make.
          </p>
        </li>
      </ul>
    </p>
    <p>
      As we study other features of Java in the next two chapters,
      we will modify the <c>OneRowNim</c> class to address these shortcomings.
    </p>
  </subsection>
</section>