<section xml:id="sec-toggle">
  <title>Example: A Toggle Button</title>
  <p>
    The ability to extend an existing class is one of the most  powerful features of object-oriented programming.
    It allows objects to reuse code defined in the superclasses without having to redefine or recompile the code.
    As we saw in Chapter<nbsp/>4, a programmer-defined JFrame,
    such as <c>GreeterGUI</c>, uses the <c>public</c> methods defined for <c>JFrame</c> s, <c>Frame</c> s, <c>Window</c> s, <c>Container</c> s, <c>Component</c> s, and <c>Object</c> s simply because it is a subclass of <c>JFrame</c>(Fig.<nbsp/>4.11).
    By the same token,
    it can use all of the <c>public</c> and <c>protected</c> instance variables and constants defined in these classes by simply referring to them in its own code.
  </p>
  <p>
    In this section,
    we present an example of how inheritance can be used to extend and customize the functionality of a Java library class.
    As we saw in Chapter<nbsp/>4,
    a <c>JButton</c> is a GUI component that can be associated with a particular action by implementing the <c>ActionListener</c> interface.
    For example,
    we used a <c>JButton</c> in the <c>GreeterGUI</c> to generate a greeting to the user.
  </p>
  <p>
    In this section, we will design a more sophisticated button.
    We will call it a <c>ToggleButton</c> and define it as a <c>JButton</c> subclass that  toggles its label whenever it is clicked,
    in addition to carrying out some kind of associated action.
  </p>
  <p>
    A light switch behaves similarly to a <c>ToggleButton</c> in this sense.
    Whenever you flick a light switch, it changes its label from
    <q>on</q>
    to
    <q>off,</q>
    but it also turns the lights on or off.
    Although different switches are associated with different lights,
    every light switch toggles its label each time it is clicked.
    So let's design a
<c>ToggleButton</c> that behaves like a light switch.
  </p>
  <p>
    The main idea in our design is that a <c>ToggleButton</c> is a
<c>JButton</c> that has two labels.
    By default, a <c>JButton</c> has just a single label.
    Thus, because of the type of behavior we want to elicit,
    we need to define <c>ToggleButton</c> as a subclass of
<c>JButton</c> with two <c>String</c> variables that will serve as its alternate labels (Fig.
    <xref ref="fig-toggleuml"></xref>).
    Note that we give it a constructor <image width="73%" source="chptr09/togglebutton.png"/> method that will allow us to provide the initial value of its two label strings.
    Another important feature of a <c>ToggleButton</c> is that it should act as its own <c>ActionListener</c> so that it can toggle its label whenever it is clicked.
    Therefore, it must also implement the <c>ActionListener</c> interface.
  </p>
  <p>
    The complete definition of <c>ToggleButton</c> is given in <xref ref="fig-togglebutton">Figure</xref>.
    Note how we have defined its constructor.
    Recall that the <c>JButton</c> class has a constructor method with the signature <c>JButton(String)</c>, which allows us to set a <c>JButton</c>'s label during instantiation.
    We need to do the same thing with one of <c>ToggleButton</c>'s two labels.
    That is, when we create a <c>ToggleButton</c>, we want to initialize its label to one of its two alternative labels
    (here,
    <q>On</q>
    or
    <q>Off</q>).
  </p>
  <figure xml:id="fig-togglebutton">
    <caption>Definition of the <c>ToggleButton</c> class.</caption>
 <program language="java"><input>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class ToggleButton extends JButton
                        implements ActionListener {
  private String label1;   // Toggle between two labels
  private String label2;
  public ToggleButton(String l1, String l2) {// Constructor
    super(l1);          // Use l1 as the default label
    label1 = l1;
    label2 = l2;
    addActionListener(this);
  }
  public void actionPerformed(ActionEvent e) {
    String tempS = label1;  // Swap the labels
    label1 = label2;
    label2 = tempS;
    setText(label1);
  } // actionPerformed()} // ToggleButton
 </input></program>
  </figure>
  <p>
    Because constructor methods are <em>not</em>
    inherited by the subclass,
    we want to invoke the superclass's constructor in the <c>ToggleButton()</c> constructor using the <c>super</c> keyword.
    This must be done as the first statement in the <c>ToggleButton()</c> constructor.
    By passing <c>l1</c> to the super constructor we are making the first string that the user gives us the default label for our <c>ToggleButton</c>. This will be the label that appears on the button when it is first displayed in a <c>Component</c>.
  </p>
  <p>
    Notice also in the <c>ToggleButton()</c> constructor that the <c>ToggleButton</c> is designated as its own <c>ActionListener</c>, so whenever it is clicked,
    its 
<c>actionPerformed()</c> method will be invoked.
    The <c>actionPerformed()</c> method exchanges the button's current label for its other label.
    Swapping two values in memory is a standard programming practice used in lots of different algorithms.
    In order to do it properly,
    you must use a third variable to temporarily store one of the two values you are swapping.
    The comments in <c>actionPerformed()</c> provide a step-by-step trace of the values of the three variables involved.
  </p>
  <principle>
    <title>PROGRAMMING TIP:Swapping Values</title>
    <p>
      It is necessary to use a temporary variable whenever you are swapping two values,
      of any type,
      in memory.
      The temporary variable holds the first value while you overwrite it with the second value.
    </p>
  </principle>
  <p>
    The first statement in <c>actionPerformed()</c> creates a temporary <c>String</c> variable named <c>tempS</c> and assigns it the value of
<c>label1</c>. Recall that label1 was the button's initial label.
    To make this example easier to follow,
    let's suppose that initially <c>label1</c> is
    <q>off</q>
    and that <c>label2</c> is
    <q>on.</q>
    After line 1 is executed,
    both <c>tempS</c> and <c>label1</c> contain
    <q>off</q>
    as their value.
    Line 2 then assigns <c>label2</c>'s value to <c>label1</c>. Now both <c>label1</c> and <c>label2</c> store
    <q>on</q>
    as their values.
    In line 3 we assign <c>tempS</c>'s value to <c>label2</c>. Now <c>label2</c> stores
    <q>off</q>
    and <c>label1</c> stores
    <q>on,</q>
    and we have effectively swapped their original values.
  </p>
  <p>
    The next time we invoke <c>actionPerformed()</c>, <c>label1</c> and <c>label2</c> will have their opposite values initially.
    Swapping them a second time will assign them their initial values again.
    We can continue toggling their values in this way indefinitely.
    To complete the method,
    the last statement in
<c>actionPerformed()</c> assigns <c>label1</c>'s current value as the new
<c>ToggleButton</c>'s label.
  </p>
  <p>
    Now that we have seen that a <c>ToggleButton</c> toggles its label between two values,
    what about performing an associated action?  To do this,
    we need a design involving multiple event handlers,
    one to handle the toggling of the button's label and the other to handle its associated action
    (<xref ref="fig-p204">Fig</xref>).
  </p>
  <figure xml:id="fig-p204">
    <caption>The <c>ToggleButton</c> has two <c>ActionListener</c> s.  When the button is clicked, the JVM will call each
    listener's <c>actionPerformed()</c> method, and each listener will take
    its own independent action.</caption>
    <image width="73%" source="chptr04/p204.png"/>
  </figure>
  <p>
    In this design, <c>lightSwitch</c> has two listeners that respond to its events:
    the <c>lightSwitch</c> itself,
    as a result of the <c>actionPerformed()</c> method in its class,
    and the <c>ToggleFrame</c>, as a result of <c>actionPerformed()</c> method in this class.
  </p>
  <p>
    The implementation of this design is given by <c>ToggleFrame</c>, a program that uses a <c>ToggleButton</c>(Fig.
    <xref ref="fig-toggletest"></xref>).
    Like the GUI we designed in Chapter<nbsp/>4,
    this program extends the <c>JFrame</c> class and implements the <c>ActionListener</c> interface.
    In this example we use a <c>ToggleButton</c> to simulate a light switch.
    Note that we assign the program itself as an <c>ActionListener</c> for the <c>lightSwitch</c>, so that
  </p>
  <figure xml:id="fig-toggletest">
    <caption>Definition of the <c>ToggleFrame</c> class.</caption>
 <program language="java"><input>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class ToggleFrame extends JFrame
                            implements ActionListener {
  private ToggleButton lightSwitch;
  public ToggleFrame() {
    lightSwitch = new ToggleButton ("off","on");
    getContentPane().add(lightSwitch);
    lightSwitch.addActionListener(this);
  } // init()
  public void actionPerformed(ActionEvent e)  {
    setTitle("The light is " + lightSwitch.getText());
  } // actionPerformed()
   public static void main(String args[])
   {
      JFrame f = new ToggleFrame();
      f.setSize(200,200);
      f.setVisible(true);
   }} // ToggleFrame
 </input></program>
  </figure>
  <p>
    When <c>lightSwitch</c> is clicked,
    the program displays the message,
    <q>The light is on,</q>
    or
    <q>The light is off,</q>
    in the program's title bar (Fig.<nbsp/>8.12).
    This is a somewhat trivial action but it illustrates that a <c>ToggleButton</c> both toggles its own label <em>and</em>
    carries out some associated action.
  </p>
  <figure xml:id="fig-toggledump">
    <caption>When clicked, <c>ToggleFrame</c>
    button causes
    <q>The light is on</q>
    or
    <q>The light is off</q>
    to appear in
    the window's title bar.</caption>
    <image width="73%" source="chptr04/4f23.png"/>
  </figure>
  <p>
    The <c>ToggleButton</c> design satisfies several key design principles of object-oriented
        <idx><h>object-oriented design</h></idx>
    programming.
    First and foremost,
    it uses inheritance to extend the functionality of the predefined <c>JButton</c> class<mdash/>the  extensibility principle.
    Secondly, it encapsulates a <c>ToggleButton</c>'s essential behavior within the <c>ToggleButton</c> class itself<mdash/>the modularity principle.
    Finally, it hides the mechanism by which a <c>ToggleButton</c> manages its labels<mdash/>the information-hiding principle.
  </p>
  <principle>
    <title>EFFECTIVE DESIGN:Inheritance</title>
    <p>
      Inheritance enables you to specialize an object's behavior.
      A <c>ToggleButton</c> does everything that a <c>JButton</c> does,
      plus it can toggle its own label.
    </p>
  </principle>
  <subsection><title>Self-Study Exercises</title>
    <ol>
      <li>
        <p>
          Write a code segment
          (not a whole method)
          to swap two boolean variables, <c>b1</c> and <c>b2</c>.
        </p>
      </li>
      <li>
        <p>
          Suppose you are designing an GUI that plays a card game,
          and you want a single button that can be used both to deal the cards and to collect the cards.
          Write a code segment that creates this type of button,
          adds it to the JFrame,
          and designates the JFrame as its
<c>ActionListener</c>.
        </p>
      </li>
    </ol>
  </subsection>
</section>