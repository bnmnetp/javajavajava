<section xml:id="objectorienteddesign-tail-recursion">
  <title>OBJECT-ORIENTED DESIGN:
  Tail Recursion</title>
  <p>
    Although the <c>drawBoxes()</c> method is relatively simple to convert into an iterative version
    (see Self-Study Exercise 12.18),
    the same cannot be said for the
<c>drawGasket()</c> method.
    It is clearly a case where the recursive approach makes the problem easier to solve.
  </p>
  <p>
    One difference between <c>drawBoxes()</c> and <c>drawGasket()</c> is that <c>drawBoxes()</c> is an example of a tail-recursive method.
    A method is <term>tail recursive</term>
        <idx><h>tail recursive</h></idx>
     if all of its recursive calls occur as the last action performed in the method.
    You have to be a bit careful about this definition.
    The recursive call in a tail-recursive method has to be the last
    <em>executed</em> statement.
    It needn't be the last statement appearing in the method's definition.
  </p>
  <p>
    For example, the following method will print
    <q>Hello</q>
    <em>N</em> times.
    This method is tail recursive even though its last statement is not a recursive call:
  </p>
 <program language="java"><input>
public void printHello(int N) {
 if (N > 1) {
   System.out.println("Hello");
   printHello(N - 1); // The last executed statement
 } else
   System.out.println("Hello");} // printHello()
 </input></program>
  <p>
    This method is tail recursive because the last statement that will be executed,
    in its recursive cases, is the recursive call.
  </p>
  <p>
    A tail-recursive method is relatively easy to convert into an iterative method.
    The basic idea is to make the recursion parameter into a loop variable,
    taking care to make sure the bounds are equivalent.
    Thus, the following iterative method will print
    <q>Hello</q>
    <em>N</em> times:
  </p>
 <program language="java"><input>
public void printHelloIterative(int N) {
    for (int k = N; k > 0; k--)
        System.out.println("Hello");}
 </input></program>
  <p>
    In this case, we use the parameter <em>N</em>
    to set the initial value of the loop variable,
    <em>k</em>, and we decrement <em>k</em> on each iteration.
    This is equivalent to what happens when we decrement the recursion parameter in the recursive call.
  </p>
  <principle>
    <title>EFFECTIVE DESIGN:Tail Recursion</title>
    <p>
      Tail-recursive algorithms are relatively simple to convert into iterative algorithms that do the same thing.
    </p>
  </principle>
  <p>
    As you can see,
    recursive methods that are not tail recursive are much more complex.
    Just compare the <c>drawGasket()</c> and
<c>drawBoxes()</c> methods.
    Yet it is precisely for these nontail-recursive algorithms that recursion turns out to be most useful.
    As you might expect,
    if you can't give a simple tail-recursive solution to a problem,
    the problem probably doesn't have a simple iterative solution either.
    Thus, the problems where we most need recursion are those where we can't give a simple tail-recursive or a simple iterative solution.
    And there are a lot of such problems,
    especially when you get into nonlinear data structures such as trees and graphs.
  </p>
  <p>
    To gain some appreciation for this complexity,
    consider how difficult it would be to draw the Sierpinski gasket using an iterative approach.
    We could start by developing an outer for loop to account for the different levels in the pattern:
  </p>
 <program language="java"><input>
for (int k = lev; k > 0; k--) {
 drawGasket(g, lev - 1, p1X, p1Y, q1X, q1Y, q2X, q2Y);
 drawGasket(g, lev - 1, p2X, p2Y, q1X, q1Y, q3X, q3Y);
 drawGasket(g, lev - 1, p3X, p3Y, q2X, q2Y, q3X, q3Y);}
 </input></program>
  <p>
    But now each of the method calls within the body of this loop would have to be replaced by very complex loops.
    That would be a daunting task.
    So the lesson to be drawn from this observation is that recursion is most useful as a problem-solving technique for problems that don't yield to a simple iterative solution.
  </p>
  <principle>
    <title>EFFECTIVE DESIGN:Recursion or Iteration</title>
    <p>
      If you have difficulty designing an iterative solution to a problem,
      try developing a recursive solution to it.
    </p>
  </principle>
  </subsection><subsection><title>Self-Study Exercises</title>
    <ol>
      <li>
        <p>
          Trace the <c>drawGasket()</c> method for levels two and three.
          Pick your own values for the three vertices.
        </p>
      </li>
      <li>
        <p>
          Is the <c>printReverse()</c> method,
          discussed earlier, tail recursive?
          Explain.
        </p>
      </li>
      <li>
        <p>
          Is the <c>countChar()</c> method,
          discussed earlier, tail recursive?
          Explain.
        </p>
      </li>
    </ol>
  </p>
</section>