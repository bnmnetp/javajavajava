<section xml:id="ch-recursion-sum">
    <title>Chapter Summary</title>
    <subsection>
      <title>Technical Terms</title> 
      <p>
       <tabular>
       <row>
      <cell>base case</cell>
      <cell>recursion parameter</cell>
       </row>
       <row>
      <cell>computational overhead</cell>
      <cell>recursive case</cell>
       </row>
       <row>
      <cell>head-and-tail algorithm</cell>
      <cell>recursive definition</cell>
       </row>
       <row>
      <cell>iterative method</cell>
      <cell>recursive method</cell>
       </row>
       <row>
      <cell>last-in-first-out (LIFO)</cell>
      <cell>self-similarity</cell>
       </row>
       <row>
      <cell>method call stack</cell>
      <cell>tail recursive</cell>
       </row>
      </tabular>
    </p>
</subsection>
<subsection>
 <title>Important Points</title>
      <ul>
        <li>
          <p>
            A <em>recursive definition</em>
            is one that defines the <em>n</em>th case of a concept in terms of the <m>(n-1)</m>st case plus a limiting condition.
            It is based on the idea of breaking a problem up into smaller,
            self-similar problems.
          </p>
        </li>
        <li>
          <p>
            A <em>recursive
              <idx><h>recursive method</h></idx>
            method</em> is one that calls itself.
            It is usually defined in terms of a
            <em>base case</em> or limiting case,
            which stops the recursive process, and a recursive case,
            which breaks the method into a smaller,
            self-similar copy of itself.
            A <em>recursion parameter</em> is generally used to control the recursion.
          </p>
        </li>
        <li>
          <p>
            An iterative algorithm is one that uses some kind of loop as its control structure.
            Any algorithm that can be done iteratively can also be done recursively,
            and vice versa.
          </p>
        </li>
        <li>
          <p>
            Because method calling is relatively costly both in terms of memory used and CPU time involved,
            a recursive algorithm is generally less efficient than an iterative one that does the same thing.
          </p>
        </li>
        <li>
          <p>
            In designing recursive algorithms,
            the <em>base case</em> defines a limit.
            Each level of recursion should make progress toward the limit,
            and the algorithm should eventually reach the limit.
            The limit is usually expressed in terms of the
            <em>recursion parameter</em>.
          </p>
        </li>
        <li>
          <p>
            A recursive method is <em>tail recursive</em>
            if and only if each of its recursive calls is the last action executed by the method.
          </p>
        </li>
        <li>
          <p>
            A Swing <c>JComboBox</c> component is used to represent a GUI drop-down menu.
          </p>
        </li>
      </ul>
</subsection>

<solutions scope="chapter-recursion" divisional="solution" project="solution" inline="solution">
  <title>Solutions to Self-Study Exercises</title>
</solutions>
</section>